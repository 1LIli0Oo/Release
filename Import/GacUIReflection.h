/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "Vlpp.h"
#include "VlppWorkflow.h"
#include "GacUI.h"

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::GuiInstanceQuery_Parser

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER


namespace vl
{
	namespace presentation
	{
		enum class GuiIqParserTokenIndex
		{
			INDIRECT = 0,
			DIRECT = 1,
			NAME = 2,
			WILDCARD = 3,
			OPEN = 4,
			CLOSE = 5,
			XOR = 6,
			INTERSECT = 7,
			UNION = 8,
			SUBSTRACT = 9,
			ATTRIBUTE = 10,
			COLON = 11,
			DOT = 12,
			SPACE = 13,
		};
		class GuiIqQuery;
		class GuiIqPrimaryQuery;
		class GuiIqCascadeQuery;
		class GuiIqSetQuery;

		class GuiIqQuery abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<GuiIqQuery>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(GuiIqPrimaryQuery* node)=0;
				virtual void Visit(GuiIqCascadeQuery* node)=0;
				virtual void Visit(GuiIqSetQuery* node)=0;
			};

			virtual void Accept(GuiIqQuery::IVisitor* visitor)=0;

		};

		enum class GuiIqNameOption
		{
			Specified,
			Any,
		};

		enum class GuiIqChildOption
		{
			Direct,
			Indirect,
		};

		class GuiIqPrimaryQuery : public GuiIqQuery, vl::reflection::Description<GuiIqPrimaryQuery>
		{
		public:
			GuiIqChildOption childOption;
			GuiIqNameOption attributeNameOption;
			vl::parsing::ParsingToken attributeName;
			GuiIqNameOption typeNameOption;
			vl::parsing::ParsingToken typeName;
			vl::parsing::ParsingToken referenceName;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqPrimaryQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class GuiIqCascadeQuery : public GuiIqQuery, vl::reflection::Description<GuiIqCascadeQuery>
		{
		public:
			vl::Ptr<GuiIqQuery> parent;
			vl::Ptr<GuiIqQuery> child;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqCascadeQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class GuiIqBinaryOperator
		{
			ExclusiveOr,
			Intersect,
			Union,
			Substract,
		};

		class GuiIqSetQuery : public GuiIqQuery, vl::reflection::Description<GuiIqSetQuery>
		{
		public:
			vl::Ptr<GuiIqQuery> first;
			vl::Ptr<GuiIqQuery> second;
			GuiIqBinaryOperator op;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqSetQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		extern vl::WString GuiIqGetParserTextBuffer();
		extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> GuiIqConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		extern vl::Ptr<vl::parsing::tabling::ParsingTable> GuiIqLoadTable();

		extern vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::presentation::GuiIqQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqNameOption)
			DECL_TYPE_INFO(vl::presentation::GuiIqChildOption)
			DECL_TYPE_INFO(vl::presentation::GuiIqPrimaryQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqCascadeQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqBinaryOperator)
			DECL_TYPE_INFO(vl::presentation::GuiIqSetQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqQuery::IVisitor)

			namespace interface_proxy
			{
				class GuiIqQuery_IVisitor : public ValueInterfaceRoot, public virtual vl::presentation::GuiIqQuery::IVisitor
				{
				public:
					GuiIqQuery_IVisitor(Ptr<IValueInterfaceProxy> proxy)
						:ValueInterfaceRoot(proxy)
					{
					}

					static Ptr<vl::presentation::GuiIqQuery::IVisitor> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiIqQuery_IVisitor(proxy);
					}

					void Visit(vl::presentation::GuiIqPrimaryQuery* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::presentation::GuiIqCascadeQuery* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::presentation::GuiIqSetQuery* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

				};

			}
#endif

			extern bool GuiIqLoadTypes();
		}
	}
}
#endif

/***********************************************************************
GUIINSTANCEREPRESENTATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Instance Representation
***********************************************************************/

		class GuiTextRepr;
		class GuiAttSetterRepr;
		class GuiConstructorRepr;
		class IGuiInstanceCache;

		class GuiValueRepr : public Object, public Description<GuiValueRepr>
		{
		public:
			class IVisitor : public IDescriptable, public Description<IVisitor>
			{
			public:
				virtual void						Visit(GuiTextRepr* repr)=0;
				virtual void						Visit(GuiAttSetterRepr* repr)=0;
				virtual void						Visit(GuiConstructorRepr* repr)=0;
			};

			bool									fromStyle = false;

			virtual void							Accept(IVisitor* visitor) = 0;
			virtual Ptr<GuiValueRepr>				Clone() = 0;
			virtual void							FillXml(Ptr<parsing::xml::XmlElement> xml) = 0;
		};

		class GuiTextRepr : public GuiValueRepr, public Description<GuiTextRepr>
		{
		public:
			static const vint						BinaryKey = 1;

			WString									text;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

		class GuiAttSetterRepr : public GuiValueRepr, public Description<GuiAttSetterRepr>
		{
		public:
			typedef collections::List<Ptr<GuiValueRepr>>						ValueList;
			static const vint						BinaryKey = 2;

			struct SetterValue : public Object, public Description<SetterValue>
			{
				GlobalStringKey						binding;
				ValueList							values;
			};

			struct EventValue : public Object, public Description<EventValue>
			{
				GlobalStringKey						binding;
				WString								value;
				bool								fromStyle = false;
			};
			
			typedef collections::Dictionary<GlobalStringKey, Ptr<SetterValue>>			SetteValuerMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<EventValue>>			EventHandlerMap;
		public:
			SetteValuerMap							setters;					// empty key means default property
			EventHandlerMap							eventHandlers;
			GlobalStringKey							instanceName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			void									CloneBody(Ptr<GuiAttSetterRepr> repr);
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

		class GuiConstructorRepr : public GuiAttSetterRepr, public Description<GuiConstructorRepr>
		{
		public:
			static const vint						BinaryKey = 3;

			GlobalStringKey							typeNamespace;
			GlobalStringKey							typeName;
			Nullable<WString>						styleName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

/***********************************************************************
Instance Namespace
***********************************************************************/

		class GuiInstanceNamespace : public Object, public Description<GuiInstanceNamespace>
		{
		public:
			WString									prefix;
			WString									postfix;
		};

		// Workflow:	<name>
		// C++:			<instance>->Get<name>
		class GuiInstanceParameter : public Object, public Description<GuiInstanceParameter>
		{
		public:
			GlobalStringKey							name;
			GlobalStringKey							className;
		};

		// Workflow:	<instance>.<name>
		// C++:			<instance>->Get<name>
		//				<instance>->Set<name>
		class GuiInstanceProperty : public Object, public Description<GuiInstanceProperty>
		{
		public:
			GlobalStringKey							name;
			WString									typeName;
			bool									readonly = false;
		};
		
		// Workflow:	<instance>.<name>
		// C++:			<instance>-><name>
		class GuiInstanceState : public Object, public Description<GuiInstanceState>
		{
		public:
			GlobalStringKey							name;
			WString									typeName;
			WString									value;
		};

/***********************************************************************
Instance Context
***********************************************************************/

		class GuiInstanceStyleContext;

		class GuiInstanceContext : public Object, public Description<GuiInstanceContext>
		{
		public:
			typedef collections::List<Ptr<GuiInstanceNamespace>>						NamespaceList;

			struct NamespaceInfo : public Object, public Description<NamespaceInfo>
			{
				GlobalStringKey						name;
				NamespaceList						namespaces;
			};
			typedef collections::Dictionary<GlobalStringKey, Ptr<NamespaceInfo>>		NamespaceMap;
			typedef collections::List<Ptr<GuiInstanceParameter>>						ParameterList;
			typedef collections::List<Ptr<GuiInstanceProperty>>							PropertyList;
			typedef collections::List<Ptr<GuiInstanceState>>							StateList;
			typedef collections::List<Ptr<GuiInstanceStyleContext>>						StyleContextList;

			class ElementName : public Object
			{
			public:
				WString								namespaceName;				// empty key means default namespace
				WString								category;
				WString								name;
				WString								binding;

				bool IsCtorName(){ return category==L"" && name!=L"" && binding==L""; }
				bool IsReferenceAttributeName(){ return namespaceName==L"" && category==L"ref" && name!=L"" && binding==L""; }
				bool IsPropertyAttributeName(){ return namespaceName==L"" && category==L"" && name!=L""; }
				bool IsPropertyElementName(){ return namespaceName==L"" && category==L"att" && name!=L""; }
				bool IsEventAttributeName(){ return namespaceName==L"" && category==L"ev" && name!=L""; }
				bool IsEventElementName(){ return namespaceName==L"" && category==L"ev" && name!=L""; }
			};
		public:
			Ptr<GuiConstructorRepr>					instance;
			NamespaceMap							namespaces;
			bool									codeBehind = true;
			WString									className;
			ParameterList							parameters;
			PropertyList							properties;
			StateList								states;
			collections::List<WString>				stylePaths;

			bool									appliedStyles = false;
			StyleContextList						styles;

			static void								CollectDefaultAttributes(GuiAttSetterRepr::ValueList& values, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static void								CollectAttributes(GuiAttSetterRepr::SetteValuerMap& setters, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static void								CollectEvents(GuiAttSetterRepr::EventHandlerMap& eventHandlers, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static void								FillAttSetter(Ptr<GuiAttSetterRepr> setter, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static Ptr<GuiConstructorRepr>			LoadCtor(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static Ptr<GuiInstanceContext>			LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
			bool									ApplyStyles(Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors);
		};

/***********************************************************************
Instance Style Context
***********************************************************************/

		class GuiInstanceStyle : public Object, public Description<GuiInstanceStyle>
		{
		public:
			Ptr<GuiIqQuery>							query;
			Ptr<GuiAttSetterRepr>					setter;

			static Ptr<GuiInstanceStyle>			LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlElement>			SaveToXml();
		};

		class GuiInstanceStyleContext : public Object, public Description<GuiInstanceStyleContext>
		{
			typedef collections::List<Ptr<GuiInstanceStyle>>		StyleList;
		public:
			StyleList								styles;

			static Ptr<GuiInstanceStyleContext>		LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
		};
	}
}

#endif

/***********************************************************************
GUIINSTANCELOADER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONINSTANCELOADER
#define VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONINSTANCELOADER


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

/***********************************************************************
Instance Loader
***********************************************************************/

		class GuiInstancePropertyInfo : public IDescriptable, public Description<GuiInstancePropertyInfo>
		{
			typedef collections::List<description::ITypeDescriptor*>		TypeDescriptorList;
		public:
			enum Support
			{
				NotSupport,
				SupportAssign,
				SupportArray,
				SupportCollection,
				SupportSet,
			};

			enum PropertyScope
			{
				ViewModel,		// <ref.Parameter/>
				Constructor,	// constructor parameter that is not ViewModel
				Property,		// property of the class
			};

			Support									support = NotSupport;
			bool									tryParent = false;
			bool									required = false;			// only apply to constructor
			bool									bindable = false;			// only apply to constructor
			PropertyScope							scope = Property;
			TypeDescriptorList						acceptableTypes;

			static Ptr<GuiInstancePropertyInfo>		Unsupported();
			static Ptr<GuiInstancePropertyInfo>		Assign(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		AssignWithParent(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		Collection(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		CollectionWithParent(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		Set(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		Array(description::ITypeDescriptor* typeDescriptor = 0);
		};

		class IGuiInstanceLoader : public IDescriptable, public Description<IGuiInstanceLoader>
		{
		public:
			struct TypeInfo
			{
				GlobalStringKey						typeName;
				description::ITypeDescriptor*		typeDescriptor;

				TypeInfo() :typeDescriptor(0){}
				TypeInfo(GlobalStringKey _typeName, description::ITypeDescriptor* _typeDescriptor)
					:typeName(_typeName)
					, typeDescriptor(_typeDescriptor)
				{
				}
			};

			struct PropertyInfo
			{
				TypeInfo							typeInfo;
				GlobalStringKey						propertyName;

				PropertyInfo(){}
				PropertyInfo(const TypeInfo& _typeInfo, GlobalStringKey _propertyName)
					:typeInfo(_typeInfo)
					, propertyName(_propertyName)
				{
				}
			};

			struct PropertyValue : PropertyInfo
			{
				description::Value					instanceValue;
				description::Value					propertyValue;

				PropertyValue(){}
				PropertyValue(const TypeInfo& _typeInfo, GlobalStringKey _propertyName, description::Value _instanceValue, description::Value _propertyValue = description::Value())
					:PropertyInfo(_typeInfo, _propertyName)
					, instanceValue(_instanceValue)
					, propertyValue(_propertyValue)
				{
				}
			};

			struct ArgumentInfo
			{
				Ptr<workflow::WfExpression>			expression;
				description::ITypeDescriptor*		type;
			};

			typedef collections::Group<GlobalStringKey, ArgumentInfo>	ArgumentMap;

			virtual GlobalStringKey					GetTypeName() = 0;

			virtual void							GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void							GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void							GetPairedProperties(const PropertyInfo& propertyInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual Ptr<GuiInstancePropertyInfo>	GetPropertyType(const PropertyInfo& propertyInfo);

			virtual bool							CanCreate(const TypeInfo& typeInfo);
			virtual Ptr<workflow::WfStatement>		CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors);
			virtual Ptr<workflow::WfStatement>		AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors);
			virtual Ptr<workflow::WfExpression>		GetParameter(const PropertyInfo& propertyInfo, GlobalStringKey variableName, collections::List<WString>& errors);
		};

/***********************************************************************
Instance Binder
***********************************************************************/

		class IGuiInstanceBinder : public IDescriptable, public Description<IGuiInstanceBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual bool							ApplicableToConstructorArgument() = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, const WString& code, collections::List<WString>& errors) = 0;
		};

		class IGuiInstanceEventBinder : public IDescriptable, public Description<IGuiInstanceEventBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& code, collections::List<WString>& errors) = 0;
		};

/***********************************************************************
Instance Loader Manager
***********************************************************************/

		class GuiInstanceConstructorResult : public Object
		{
		public:
			Ptr<workflow::runtime::WfRuntimeGlobalContext>	context;
		};

		class IGuiInstanceLoaderManager : public IDescriptable, public Description<IGuiInstanceLoaderManager>
		{
		public:
			virtual bool								AddInstanceBinder(Ptr<IGuiInstanceBinder> binder) = 0;
			virtual IGuiInstanceBinder*					GetInstanceBinder(GlobalStringKey bindingName) = 0;
			virtual bool								AddInstanceEventBinder(Ptr<IGuiInstanceEventBinder> binder) = 0;
			virtual IGuiInstanceEventBinder*			GetInstanceEventBinder(GlobalStringKey bindingName) = 0;
			virtual bool								CreateVirtualType(GlobalStringKey parentType, Ptr<IGuiInstanceLoader> loader) = 0;
			virtual bool								SetLoader(Ptr<IGuiInstanceLoader> loader) = 0;
			virtual IGuiInstanceLoader*					GetLoader(GlobalStringKey typeName) = 0;
			virtual IGuiInstanceLoader*					GetParentLoader(IGuiInstanceLoader* loader) = 0;
			virtual description::ITypeDescriptor*		GetTypeDescriptorForType(GlobalStringKey typeName) = 0;
			virtual void								GetVirtualTypes(collections::List<GlobalStringKey>& typeNames) = 0;
			virtual GlobalStringKey						GetParentTypeForVirtualType(GlobalStringKey virtualType) = 0;
			virtual bool								SetResource(const WString& name, Ptr<GuiResource> resource, GuiResourceUsage usage = GuiResourceUsage::Application) = 0;
			virtual Ptr<GuiResource>					GetResource(const WString& name) = 0;
			virtual Ptr<GuiInstanceConstructorResult>	RunInstanceConstructor(const WString& classFullName, description::Value instance) = 0;
		};

		struct InstanceLoadingSource
		{
			IGuiInstanceLoader*						loader;
			GlobalStringKey							typeName;
			Ptr<GuiResourceItem>					item;
			Ptr<GuiInstanceContext>					context;

			InstanceLoadingSource()
				:loader(0)
			{
			}

			InstanceLoadingSource(IGuiInstanceLoader* _loader, GlobalStringKey _typeName)
				:loader(_loader)
				, typeName(_typeName)
			{
			}

			InstanceLoadingSource(Ptr<GuiResourceItem> _item)
				:loader(0)
				, item(_item)
				, context(item->GetContent().Cast<GuiInstanceContext>())
			{
			}

			operator bool()const
			{
				return loader != 0 || context;
			}
		};

		extern IGuiInstanceLoaderManager*			GetInstanceLoaderManager();
		extern InstanceLoadingSource				FindInstanceLoadingSource(Ptr<GuiInstanceContext> context, GuiConstructorRepr* ctor);

/***********************************************************************
Instance Scope Wrapper
***********************************************************************/

		template<typename T>
		class GuiInstancePartialClass
		{
		private:
			WString											className;
			Ptr<workflow::runtime::WfRuntimeGlobalContext>	context;

		protected:
			bool InitializeFromResource()
			{
				if (!context)
				{
					auto value = description::Value::From(dynamic_cast<T*>(this));
					if (auto result = GetInstanceLoaderManager()->RunInstanceConstructor(className, value))
					{
						context = result->context;
						return true;
					}
				}
				return false;
			}

			template<typename TControl>
			void LoadInstanceReference(const WString& name, TControl*& reference)
			{
				reference = 0;
				vint index = context->assembly->variableNames.IndexOf(name);
				CHECK_ERROR(index != -1, L"GuiInstancePartialClass<T>::LoadInstanceReference<TControl>(const WString&, TControl*&)#Failed to find instance reference.");

				auto value = context->globalVariables->variables[index];
				auto td = description::GetTypeDescriptor<TControl>();
				if (!value.GetTypeDescriptor() || !value.GetTypeDescriptor()->CanConvertTo(td))
				{
					CHECK_ERROR(index != -1, L"GuiInstancePartialClass<T>::LoadInstanceReference<TControl>(const WString&, TControl*&)#Wrong instance reference type.");
					return;
				}

				reference = description::UnboxValue<TControl*>(value);
			}
		public:
			GuiInstancePartialClass(const WString& _className)
				:className(_className)
			{
			}

			virtual ~GuiInstancePartialClass()
			{
			}
		};

#define GUI_INSTANCE_REFERENCE(NAME) LoadInstanceReference(L ## #NAME, this->NAME)
	}
}

#endif

/***********************************************************************
GUIINSTANCEHELPERTYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Helper Types

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEHELPERTYPES
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEHELPERTYPES


#if defined(__APPLE__) || defined(__APPLE_CC__)

using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::templates;
using namespace vl::presentation::theme;

#endif

namespace vl
{
	namespace presentation
	{

/***********************************************************************
Helper Types
***********************************************************************/

		namespace helper_types
		{
			struct SiteValue
			{
				vint			row;
				vint			column;
				vint			rowSpan;
				vint			columnSpan;

				SiteValue() :row(0), column(0), rowSpan(1), columnSpan(1){}
			};

			enum class ListViewViewType
			{
				BigIcon,
				SmallIcon,
				List,
				Tile,
				Information,
				Detail,
			};
		}
	}

#ifndef VCZH_DEBUG_NO_REFLECTION

	namespace reflection
	{
		namespace description
		{

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONHELPERTYPES_TYPELIST(F)\
			F(presentation::helper_types::SiteValue)\
			F(presentation::helper_types::ListViewViewType)\

			GUIREFLECTIONHELPERTYPES_TYPELIST(DECL_TYPE_INFO)
		}
	}

#endif
}

#endif

/***********************************************************************
GUIINSTANCESHAREDSCRIPT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT


namespace vl
{
	namespace presentation
	{
		class GuiInstanceSharedScript :public Object, public Description<GuiInstanceSharedScript>
		{
		public:
			WString										language;
			WString										code;

			static Ptr<GuiInstanceSharedScript>			LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlElement>				SaveToXml();
		};

		class GuiInstanceCompiledWorkflow : public Object, public Description<GuiInstanceCompiledWorkflow>
		{
		public:
			enum AssemblyType
			{
				ViewModel,
				Shared,
				InstanceCtor,
				InstanceClass,
			};
			
			collections::List<WString>						codes;
			Ptr<stream::MemoryStream>						binaryToLoad;

			AssemblyType									type = AssemblyType::Shared;
			WString											classFullName;
			Ptr<workflow::runtime::WfAssembly>				assembly;
			Ptr<workflow::runtime::WfRuntimeGlobalContext>	context;

			void											Initialize(bool initializeContext);
		};
	}
}

#endif

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONBASIC.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Basic

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONBASIC
#define VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONBASIC


namespace vl
{
	namespace reflection
	{
		namespace description
		{

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONBASIC_TYPELIST(F)\
			F(presentation::Color)\
			F(presentation::Alignment)\
			F(presentation::AxisDirection)\
			F(presentation::TextPos)\
			F(presentation::GridPos)\
			F(presentation::Point)\
			F(presentation::Size)\
			F(presentation::Rect)\
			F(presentation::Margin)\
			F(presentation::FontProperties)\
			F(presentation::GlobalStringKey)\
			F(presentation::INativeImageFrame)\
			F(presentation::INativeImage)\
			F(presentation::INativeImage::FormatType)\
			F(presentation::INativeCursor)\
			F(presentation::INativeCursor::SystemCursorType)\
			F(presentation::INativeWindow)\
			F(presentation::INativeWindow::WindowSizeState)\
			F(presentation::INativeDelay)\
			F(presentation::INativeDelay::ExecuteStatus)\
			F(presentation::INativeScreen)\
			F(presentation::INativeImageService)\
			F(presentation::INativeResourceService)\
			F(presentation::INativeAsyncService)\
			F(presentation::INativeClipboardService)\
			F(presentation::INativeScreenService)\
			F(presentation::INativeInputService)\
			F(presentation::INativeDialogService::MessageBoxButtonsInput)\
			F(presentation::INativeDialogService::MessageBoxButtonsOutput)\
			F(presentation::INativeDialogService::MessageBoxDefaultButton)\
			F(presentation::INativeDialogService::MessageBoxIcons)\
			F(presentation::INativeDialogService::MessageBoxModalOptions)\
			F(presentation::INativeDialogService::ColorDialogCustomColorOptions)\
			F(presentation::INativeDialogService::FileDialogTypes)\
			F(presentation::INativeDialogService::FileDialogOptions)\
			F(presentation::INativeController)\
			F(presentation::GuiImageData)\
			F(presentation::GuiTextData)\
			F(presentation::DocumentStyleProperties)\
			F(presentation::DocumentRun)\
			F(presentation::DocumentContainerRun)\
			F(presentation::DocumentContentRun)\
			F(presentation::DocumentTextRun)\
			F(presentation::DocumentInlineObjectRun)\
			F(presentation::DocumentImageRun)\
			F(presentation::DocumentEmbeddedObjectRun)\
			F(presentation::DocumentStylePropertiesRun)\
			F(presentation::DocumentStyleApplicationRun)\
			F(presentation::DocumentHyperlinkRun)\
			F(presentation::DocumentParagraphRun)\
			F(presentation::DocumentStyle)\
			F(presentation::DocumentModel)\
			F(presentation::GuiInstanceSharedScript)\
			F(presentation::GuiInstanceStyle)\
			F(presentation::GuiInstanceStyleContext)\
			F(presentation::GuiValueRepr)\
			F(presentation::GuiTextRepr)\
			F(presentation::GuiAttSetterRepr)\
			F(presentation::GuiAttSetterRepr::SetterValue)\
			F(presentation::GuiAttSetterRepr::EventValue)\
			F(presentation::GuiConstructorRepr)\
			F(presentation::GuiInstanceNamespace)\
			F(presentation::GuiInstanceParameter)\
			F(presentation::GuiInstanceProperty)\
			F(presentation::GuiInstanceState)\
			F(presentation::GuiInstanceContext)\
			F(presentation::GuiInstanceContext::NamespaceInfo)\
			F(presentation::GuiResourceNodeBase)\
			F(presentation::GuiResourceItem)\
			F(presentation::GuiResourceFolder)\
			F(presentation::GuiResource)\
			F(presentation::GuiResourcePathResolver)\
			F(presentation::elements::IGuiGraphicsElement)\
			F(presentation::compositions::GuiGraphicsComposition)\
			F(presentation::compositions::GuiGraphicsComposition::MinSizeLimitation)\
			F(presentation::INativeWindowListener::HitTestResult)\
			F(presentation::compositions::GuiGraphicsSite)\
			F(presentation::compositions::GuiWindowComposition)\
			F(presentation::compositions::GuiBoundsComposition)\
			F(presentation::controls::GuiControl)\
			F(presentation::controls::GuiControl::IStyleController)\
			F(presentation::controls::GuiControl::IStyleProvider)\
			F(presentation::controls::GuiComponent)\
			F(presentation::controls::GuiControlHost)\

			GUIREFLECTIONBASIC_TYPELIST(DECL_TYPE_INFO)

/***********************************************************************
Type Declaration
***********************************************************************/

			template<>
			struct TypedValueSerializerProvider<presentation::Color>
			{
				static presentation::Color GetDefaultValue();
				static bool Serialize(const presentation::Color& input, WString& output);
				static bool Deserialize(const WString& input, presentation::Color& output);
			};

			template<>
			struct CustomTypeDescriptorSelector<presentation::Color>
			{
			public:
				typedef SerializableTypeDescriptor<TypedDefaultValueSerializer<presentation::Color>> CustomTypeDescriptorImpl;
			};

			template<>
			struct TypedValueSerializerProvider<presentation::GlobalStringKey>
			{
				static presentation::GlobalStringKey GetDefaultValue();
				static bool Serialize(const presentation::GlobalStringKey& input, WString& output);
				static bool Deserialize(const WString& input, presentation::GlobalStringKey& output);
			};

			template<>
			struct CustomTypeDescriptorSelector<presentation::GlobalStringKey>
			{
			public:
				typedef SerializableTypeDescriptor<TypedDefaultValueSerializer<presentation::GlobalStringKey>> CustomTypeDescriptorImpl;
			};

/***********************************************************************
Interface Proxy
***********************************************************************/

			namespace interface_proxy
			{
				using namespace presentation;
				using namespace presentation::controls;

				class GuiControl_IStyleController : public ValueInterfaceRoot, public virtual GuiControl::IStyleController
				{
				public:
					GuiControl_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static GuiControl::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiControl_IStyleController(_proxy);
					}

					compositions::GuiBoundsComposition* GetBoundsComposition()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBoundsComposition);
					}

					compositions::GuiGraphicsComposition* GetContainerComposition()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetContainerComposition);
					}

					void SetFocusableComposition(compositions::GuiGraphicsComposition* value)override
					{
						INVOKE_INTERFACE_PROXY(SetFocusableComposition, value);
					}

					void SetText(const WString& value)override
					{
						INVOKE_INTERFACE_PROXY(SetText, value);
					}

					void SetFont(const FontProperties& value)override
					{
						INVOKE_INTERFACE_PROXY(SetFont, value);
					}

					void SetVisuallyEnabled(bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetVisuallyEnabled, value);
					}
				};
				
				class GuiControl_IStyleProvider : public ValueInterfaceRoot, public virtual GuiControl::IStyleProvider
				{
				public:
					GuiControl_IStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static GuiControl::IStyleProvider* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiControl_IStyleProvider(_proxy);
					}

					void AssociateStyleController(GuiControl::IStyleController* controller)override
					{
						INVOKE_INTERFACE_PROXY(AssociateStyleController, controller);
					}

					void SetFocusableComposition(compositions::GuiGraphicsComposition* value)override
					{
						INVOKE_INTERFACE_PROXY(SetFocusableComposition, value);
					}

					void SetText(const WString& value)override
					{
						INVOKE_INTERFACE_PROXY(SetText, value);
					}

					void SetFont(const FontProperties& value)override
					{
						INVOKE_INTERFACE_PROXY(SetFont, value);
					}

					void SetVisuallyEnabled(bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetVisuallyEnabled, value);
					}
				};
			}

/***********************************************************************
Type Loader
***********************************************************************/

#endif

			extern bool						LoadGuiBasicTypes();
		}
	}
}

#endif

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONELEMENTS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Elements

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONELEMENTS
#define VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONELEMENTS


namespace vl
{
	namespace reflection
	{
		namespace description
		{

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONELEMENT_TYPELIST(F)\
			F(presentation::elements::IGuiGraphicsParagraph)\
			F(presentation::elements::IGuiGraphicsParagraph::CaretRelativePosition)\
			F(presentation::elements::ElementShape)\
			F(presentation::elements::GuiSolidBorderElement)\
			F(presentation::elements::GuiRoundBorderElement)\
			F(presentation::elements::Gui3DBorderElement)\
			F(presentation::elements::Gui3DSplitterElement)\
			F(presentation::elements::Gui3DSplitterElement::Direction)\
			F(presentation::elements::GuiSolidBackgroundElement)\
			F(presentation::elements::GuiGradientBackgroundElement)\
			F(presentation::elements::GuiGradientBackgroundElement::Direction)\
			F(presentation::elements::GuiSolidLabelElement)\
			F(presentation::elements::GuiImageFrameElement)\
			F(presentation::elements::GuiPolygonElement)\
			F(presentation::elements::text::TextLines)\
			F(presentation::elements::text::ColorItem)\
			F(presentation::elements::text::ColorEntry)\
			F(presentation::elements::GuiColorizedTextElement)\
			F(presentation::elements::GuiDocumentElement)\

			GUIREFLECTIONELEMENT_TYPELIST(DECL_TYPE_INFO)

/***********************************************************************
Type Loader
***********************************************************************/

#endif

			extern bool						LoadGuiElementTypes();
		}
	}
}

#endif

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONCOMPOSITIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Compositions

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONCOMPOSITIONS
#define VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONCOMPOSITIONS


namespace vl
{
	namespace reflection
	{
		namespace description
		{

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONCOMPOSITION_TYPELIST(F)\
			F(presentation::compositions::KeyDirection)\
			F(presentation::compositions::IGuiAxis)\
			F(presentation::compositions::GuiDefaultAxis)\
			F(presentation::compositions::GuiAxis)\
			F(presentation::compositions::GuiStackComposition)\
			F(presentation::compositions::GuiStackComposition::Direction)\
			F(presentation::compositions::GuiStackItemComposition)\
			F(presentation::compositions::GuiCellOption)\
			F(presentation::compositions::GuiCellOption::ComposeType)\
			F(presentation::compositions::GuiTableComposition)\
			F(presentation::compositions::GuiCellComposition)\
			F(presentation::compositions::FlowAlignment)\
			F(presentation::compositions::GuiFlowComposition)\
			F(presentation::compositions::GuiFlowOption)\
			F(presentation::compositions::GuiFlowOption::BaselineType)\
			F(presentation::compositions::GuiFlowItemComposition)\
			F(presentation::compositions::GuiSideAlignedComposition)\
			F(presentation::compositions::GuiSideAlignedComposition::Direction)\
			F(presentation::compositions::GuiPartialViewComposition)\
			F(presentation::compositions::GuiSharedSizeItemComposition)\
			F(presentation::compositions::GuiSharedSizeRootComposition)\
			F(presentation::compositions::IGuiGraphicsAnimation)\
			F(presentation::compositions::GuiGraphicsAnimationManager)\
			F(presentation::compositions::IGuiShortcutKeyItem)\
			F(presentation::compositions::IGuiShortcutKeyManager)\
			F(presentation::compositions::GuiShortcutKeyManager)\
			F(presentation::compositions::IGuiAltAction)\
			F(presentation::compositions::IGuiAltActionContainer)\
			F(presentation::compositions::IGuiAltActionHost)\

			GUIREFLECTIONCOMPOSITION_TYPELIST(DECL_TYPE_INFO)

/***********************************************************************
Interface Proxy
***********************************************************************/

#pragma warning(push)
#pragma warning(disable:4250)
			namespace interface_proxy
			{
				using namespace presentation;
				using namespace presentation::compositions;

				class composition_IGuiGraphicsAnimation : public ValueInterfaceRoot, public virtual IGuiGraphicsAnimation
				{
				public:
					composition_IGuiGraphicsAnimation(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<IGuiGraphicsAnimation> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new composition_IGuiGraphicsAnimation(proxy);
					}

					vint GetTotalLength()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetTotalLength);
					}

					vint GetCurrentPosition()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetCurrentPosition);
					}

					void Play(vint currentPosition, vint totalLength)override
					{
						INVOKE_INTERFACE_PROXY(Play, currentPosition, totalLength);
					}

					void Stop()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(Stop);
					}
				};

				class compositions_IGuiAxis : public ValueInterfaceRoot, public virtual IGuiAxis
				{
				public:
					compositions_IGuiAxis(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<IGuiAxis> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new compositions_IGuiAxis(proxy);
					}

					Size RealSizeToVirtualSize(Size size)override
					{
						return INVOKEGET_INTERFACE_PROXY(RealSizeToVirtualSize, size);
					}

					Size VirtualSizeToRealSize(Size size)override
					{
						return INVOKEGET_INTERFACE_PROXY(VirtualSizeToRealSize, size);
					}

					Point RealPointToVirtualPoint(Size realFullSize, Point point)override
					{
						return INVOKEGET_INTERFACE_PROXY(RealPointToVirtualPoint, realFullSize, point);
					}

					Point VirtualPointToRealPoint(Size realFullSize, Point point)override
					{
						return INVOKEGET_INTERFACE_PROXY(VirtualPointToRealPoint, realFullSize, point);
					}

					Rect RealRectToVirtualRect(Size realFullSize, Rect rect)override
					{
						return INVOKEGET_INTERFACE_PROXY(RealRectToVirtualRect, realFullSize, rect);
					}

					Rect VirtualRectToRealRect(Size realFullSize, Rect rect)override
					{
						return INVOKEGET_INTERFACE_PROXY(VirtualRectToRealRect, realFullSize, rect);
					}

					Margin RealMarginToVirtualMargin(Margin margin)override
					{
						return INVOKEGET_INTERFACE_PROXY(RealMarginToVirtualMargin, margin);
					}

					Margin VirtualMarginToRealMargin(Margin margin)override
					{
						return INVOKEGET_INTERFACE_PROXY(VirtualMarginToRealMargin, margin);
					}

					KeyDirection RealKeyDirectionToVirtualKeyDirection(KeyDirection key)override
					{
						return INVOKEGET_INTERFACE_PROXY(RealKeyDirectionToVirtualKeyDirection, key);
					}
				};
			}
#pragma warning(pop)

/***********************************************************************
Type Loader
***********************************************************************/

#endif

			extern bool						LoadGuiCompositionTypes();
		}
	}
}

#endif

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Basic

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONCONTROLS
#define VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONCONTROLS


namespace vl
{
	namespace reflection
	{
		namespace description
		{

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONCONTROLS_TYPELIST(F)\
			F(presentation::controls::GuiApplication)\
			F(presentation::theme::ITheme)\
			F(presentation::controls::GuiInstanceRootObject)\
			F(presentation::controls::GuiDialogBase)\
			F(presentation::controls::GuiMessageDialog)\
			F(presentation::controls::GuiColorDialog)\
			F(presentation::controls::GuiFontDialog)\
			F(presentation::controls::GuiFileDialogBase)\
			F(presentation::controls::GuiOpenFileDialog)\
			F(presentation::controls::GuiSaveFileDialog)\
			F(presentation::controls::GuiCustomControl)\
			F(presentation::controls::GuiLabel)\
			F(presentation::controls::GuiLabel::IStyleController)\
			F(presentation::controls::GuiButton)\
			F(presentation::controls::GuiButton::ControlState)\
			F(presentation::controls::GuiButton::IStyleController)\
			F(presentation::controls::GuiSelectableButton)\
			F(presentation::controls::GuiSelectableButton::IStyleController)\
			F(presentation::controls::GuiSelectableButton::GroupController)\
			F(presentation::controls::GuiSelectableButton::MutexGroupController)\
			F(presentation::controls::GuiScroll)\
			F(presentation::controls::GuiScroll::ICommandExecutor)\
			F(presentation::controls::GuiScroll::IStyleController)\
			F(presentation::controls::GuiTabPage)\
			F(presentation::controls::GuiTab)\
			F(presentation::controls::GuiTab::ICommandExecutor)\
			F(presentation::controls::GuiTab::IStyleController)\
			F(presentation::controls::GuiScrollView)\
			F(presentation::controls::GuiScrollView::IStyleProvider)\
			F(presentation::controls::GuiScrollContainer)\
			F(presentation::controls::GuiWindow)\
			F(presentation::controls::GuiWindow::IStyleController)\
			F(presentation::controls::GuiPopup)\
			F(presentation::controls::GuiTooltip)\
			F(presentation::controls::GuiListControl)\
			F(presentation::controls::GuiListControl::IItemProviderCallback)\
			F(presentation::controls::GuiListControl::IItemArrangerCallback)\
			F(presentation::controls::GuiListControl::IItemPrimaryTextView)\
			F(presentation::controls::GuiListControl::IItemBindingView)\
			F(presentation::controls::GuiListControl::IItemProvider)\
			F(presentation::controls::GuiListControl::IItemStyleController)\
			F(presentation::controls::GuiListControl::IItemStyleProvider)\
			F(presentation::controls::GuiListControl::IItemArranger)\
			F(presentation::controls::GuiSelectableListControl)\
			F(presentation::controls::GuiSelectableListControl::IItemStyleProvider)\
			F(presentation::controls::list::RangedItemArrangerBase)\
			F(presentation::controls::list::FixedHeightItemArranger)\
			F(presentation::controls::list::FixedSizeMultiColumnItemArranger)\
			F(presentation::controls::list::FixedHeightMultiColumnItemArranger)\
			F(presentation::controls::list::ItemStyleControllerBase)\
			F(presentation::controls::list::TextItemStyleProvider)\
			F(presentation::controls::list::TextItemStyleProvider::ITextItemStyleProvider)\
			F(presentation::controls::list::TextItemStyleProvider::ITextItemView)\
			F(presentation::controls::list::TextItemStyleProvider::TextItemStyleController)\
			F(presentation::controls::list::TextItem)\
			F(presentation::controls::GuiVirtualTextList)\
			F(presentation::controls::GuiTextList)\
			F(presentation::controls::list::ListViewItemStyleProviderBase)\
			F(presentation::controls::list::ListViewItemStyleProviderBase::ListViewItemStyleController)\
			F(presentation::controls::GuiListViewColumnHeader)\
			F(presentation::controls::GuiListViewColumnHeader::ColumnSortingState)\
			F(presentation::controls::GuiListViewColumnHeader::IStyleController)\
			F(presentation::controls::GuiListViewBase)\
			F(presentation::controls::GuiListViewBase::IStyleProvider)\
			F(presentation::controls::list::ListViewItemStyleProvider)\
			F(presentation::controls::list::ListViewItemStyleProvider::IListViewItemView)\
			F(presentation::controls::list::ListViewItemStyleProvider::IListViewItemContent)\
			F(presentation::controls::list::ListViewItemStyleProvider::IListViewItemContentProvider)\
			F(presentation::controls::list::ListViewItemStyleProvider::ListViewContentItemStyleController)\
			F(presentation::controls::list::ListViewBigIconContentProvider)\
			F(presentation::controls::list::ListViewSmallIconContentProvider)\
			F(presentation::controls::list::ListViewListContentProvider)\
			F(presentation::controls::list::ListViewTileContentProvider)\
			F(presentation::controls::list::ListViewInformationContentProvider)\
			F(presentation::controls::list::ListViewColumnItemArranger)\
			F(presentation::controls::list::ListViewColumnItemArranger::IColumnItemViewCallback)\
			F(presentation::controls::list::ListViewColumnItemArranger::IColumnItemView)\
			F(presentation::controls::list::ListViewDetailContentProvider)\
			F(presentation::controls::list::ListViewItem)\
			F(presentation::controls::list::ListViewColumn)\
			F(presentation::controls::GuiVirtualListView)\
			F(presentation::controls::GuiListView)\
			F(presentation::controls::IGuiMenuService)\
			F(presentation::controls::IGuiMenuService::Direction)\
			F(presentation::controls::GuiMenu)\
			F(presentation::controls::GuiMenuBar)\
			F(presentation::controls::GuiMenuButton)\
			F(presentation::controls::GuiMenuButton::IStyleController)\
			F(presentation::controls::tree::INodeProviderCallback)\
			F(presentation::controls::tree::INodeProvider)\
			F(presentation::controls::tree::INodeRootProvider)\
			F(presentation::controls::tree::INodeItemView)\
			F(presentation::controls::tree::INodeItemPrimaryTextView)\
			F(presentation::controls::tree::INodeItemBindingView)\
			F(presentation::controls::tree::INodeItemStyleController)\
			F(presentation::controls::tree::INodeItemStyleProvider)\
			F(presentation::controls::tree::NodeItemStyleProvider)\
			F(presentation::controls::tree::IMemoryNodeData)\
			F(presentation::controls::tree::MemoryNodeProvider)\
			F(presentation::controls::tree::NodeRootProviderBase)\
			F(presentation::controls::tree::MemoryNodeRootProvider)\
			F(presentation::controls::GuiVirtualTreeListControl)\
			F(presentation::controls::tree::ITreeViewItemView)\
			F(presentation::controls::tree::TreeViewItem)\
			F(presentation::controls::tree::TreeViewItemRootProvider)\
			F(presentation::controls::GuiVirtualTreeView)\
			F(presentation::controls::GuiVirtualTreeView::IStyleProvider)\
			F(presentation::controls::GuiTreeView)\
			F(presentation::controls::tree::TreeViewNodeItemStyleProvider)\
			F(presentation::controls::GuiComboBoxBase)\
			F(presentation::controls::GuiComboBoxBase::ICommandExecutor)\
			F(presentation::controls::GuiComboBoxBase::IStyleController)\
			F(presentation::controls::GuiComboBoxListControl)\
			F(presentation::controls::GuiToolstripCommand)\
			F(presentation::controls::GuiToolstripMenu)\
			F(presentation::controls::GuiToolstripMenuBar)\
			F(presentation::controls::GuiToolstripToolBar)\
			F(presentation::controls::GuiToolstripButton)\
			F(presentation::controls::GuiDocumentItem)\
			F(presentation::controls::GuiDocumentCommonInterface)\
			F(presentation::controls::GuiDocumentCommonInterface::EditMode)\
			F(presentation::controls::GuiDocumentViewer)\
			F(presentation::controls::GuiDocumentViewer::IStyleProvider)\
			F(presentation::controls::GuiDocumentLabel)\
			F(presentation::controls::GuiDocumentLabel::IStyleController)\
			F(presentation::controls::GuiTextBoxCommonInterface)\
			F(presentation::controls::GuiMultilineTextBox)\
			F(presentation::controls::GuiSinglelineTextBox)\
			F(presentation::controls::GuiSinglelineTextBox::IStyleProvider)\
			F(presentation::controls::list::IDataVisualizerFactory)\
			F(presentation::controls::list::IDataVisualizer)\
			F(presentation::controls::list::IDataEditorCallback)\
			F(presentation::controls::list::IDataEditorFactory)\
			F(presentation::controls::list::IDataEditor)\
			F(presentation::controls::list::IDataProviderCommandExecutor)\
			F(presentation::controls::list::IDataProvider)\
			F(presentation::controls::list::IStructuredDataFilterCommandExecutor)\
			F(presentation::controls::list::IStructuredDataFilter)\
			F(presentation::controls::list::IStructuredDataSorter)\
			F(presentation::controls::list::IStructuredColumnProvider)\
			F(presentation::controls::list::IStructuredDataProvider)\
			F(presentation::controls::list::DataGridContentProvider)\
			F(presentation::controls::GuiVirtualDataGrid)\
			F(presentation::controls::list::StructuredDataFilterBase)\
			F(presentation::controls::list::StructuredDataMultipleFilter)\
			F(presentation::controls::list::StructuredDataAndFilter)\
			F(presentation::controls::list::StructuredDataOrFilter)\
			F(presentation::controls::list::StructuredDataNotFilter)\
			F(presentation::controls::list::StructuredDataMultipleSorter)\
			F(presentation::controls::list::StructuredDataReverseSorter)\
			F(presentation::controls::list::StructuredDataProvider)\
			F(presentation::controls::list::StructuredColummProviderBase)\
			F(presentation::controls::list::StructuredDataProviderBase)\
			F(presentation::controls::list::ListViewMainColumnDataVisualizer)\
			F(presentation::controls::list::ListViewMainColumnDataVisualizer::Factory)\
			F(presentation::controls::list::ListViewSubColumnDataVisualizer)\
			F(presentation::controls::list::ListViewSubColumnDataVisualizer::Factory)\
			F(presentation::controls::list::HyperlinkDataVisualizer)\
			F(presentation::controls::list::HyperlinkDataVisualizer::Factory)\
			F(presentation::controls::list::ImageDataVisualizer)\
			F(presentation::controls::list::ImageDataVisualizer::Factory)\
			F(presentation::controls::list::CellBorderDataVisualizer)\
			F(presentation::controls::list::CellBorderDataVisualizer::Factory)\
			F(presentation::controls::list::NotifyIconDataVisualizer)\
			F(presentation::controls::list::NotifyIconDataVisualizer::Factory)\
			F(presentation::controls::list::TextBoxDataEditor)\
			F(presentation::controls::list::TextBoxDataEditor::Factory)\
			F(presentation::controls::list::TextComboBoxDataEditor)\
			F(presentation::controls::list::TextComboBoxDataEditor::Factory)\
			F(presentation::controls::list::DateComboBoxDataEditor)\
			F(presentation::controls::list::DateComboBoxDataEditor::Factory)\
			F(presentation::controls::GuiDatePicker)\
			F(presentation::controls::GuiDatePicker::IStyleProvider)\
			F(presentation::controls::GuiDateComboBox)\
			F(presentation::controls::GuiStringGrid)\
			F(presentation::controls::list::StringGridProvider)\
			F(presentation::controls::GuiBindableTextList)\
			F(presentation::controls::GuiBindableListView)\
			F(presentation::controls::GuiBindableTreeView)\
			F(presentation::controls::list::BindableDataColumn)\
			F(presentation::controls::GuiBindableDataGrid)\

			GUIREFLECTIONCONTROLS_TYPELIST(DECL_TYPE_INFO)

/***********************************************************************
Interface Proxy
***********************************************************************/

#pragma warning(push)
#pragma warning(disable:4250)
			namespace interface_proxy
			{
				class GuiCustomControl_IStyleController : public virtual GuiControl_IStyleController, public virtual GuiCustomControl::IStyleController
				{
				public:
					GuiCustomControl_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
					{
					}

					static GuiCustomControl::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiCustomControl_IStyleController(_proxy);
					}
				};

				class GuiLabel_IStyleController : public virtual GuiControl_IStyleController, public virtual GuiLabel::IStyleController
				{
				public:
					GuiLabel_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
					{
					}

					static GuiLabel::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiLabel_IStyleController(_proxy);
					}

					Color GetDefaultTextColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetDefaultTextColor);
					}

					void SetTextColor(Color value)override
					{
						INVOKE_INTERFACE_PROXY(SetTextColor, value);
					}
				};

				class GuiButton_IStyleController : public virtual GuiControl_IStyleController, public virtual GuiButton::IStyleController
				{
				public:
					GuiButton_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
					{
					}

					static GuiButton::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiButton_IStyleController(_proxy);
					}

					void Transfer(GuiButton::ControlState value)override
					{
						INVOKE_INTERFACE_PROXY(Transfer, value);
					}
				};

				class GuiSelectableButton_IStyleController : public virtual GuiButton_IStyleController, public virtual GuiSelectableButton::IStyleController
				{
				public:
					GuiSelectableButton_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
						,GuiButton_IStyleController(_proxy)
					{
					}

					static GuiSelectableButton::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiSelectableButton_IStyleController(_proxy);
					}

					void SetSelected(bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetSelected, value);
					}
				};

				class GuiScroll_IStyleController : public virtual GuiControl_IStyleController, public virtual GuiScroll::IStyleController
				{
				public:
					GuiScroll_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
					{
					}

					static GuiScroll::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiScroll_IStyleController(_proxy);
					}

					void SetCommandExecutor(GuiScroll::ICommandExecutor* value)override
					{
						INVOKE_INTERFACE_PROXY(SetCommandExecutor, value);
					}

					void SetTotalSize(vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetTotalSize, value);
					}

					void SetPageSize(vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetPageSize, value);
					}

					void SetPosition(vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetPosition, value);
					}
				};

				class GuiTab_IStyleController : public virtual GuiControl_IStyleController, public virtual GuiTab::IStyleController
				{
				public:
					GuiTab_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
					{
					}

					static GuiTab::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiTab_IStyleController(_proxy);
					}

					void SetCommandExecutor(GuiTab::ICommandExecutor* value)override
					{
						INVOKE_INTERFACE_PROXY(SetCommandExecutor, value);
					}

					void InsertTab(vint index)override
					{
						INVOKE_INTERFACE_PROXY(InsertTab, index);
					}

					void SetTabText(vint index, const WString& value)override
					{
						INVOKE_INTERFACE_PROXY(SetTabText, index, value);
					}

					void RemoveTab(vint index)override
					{
						INVOKE_INTERFACE_PROXY(RemoveTab, index);
					}

					void MoveTab(vint oldIndex, vint newIndex)override
					{
						INVOKE_INTERFACE_PROXY(MoveTab, oldIndex, newIndex);
					}

					void SetSelectedTab(vint index)override
					{
						INVOKE_INTERFACE_PROXY(SetSelectedTab, index);
					}

					void SetTabAlt(vint index, const WString& value, compositions::IGuiAltActionHost* host)override
					{
						INVOKE_INTERFACE_PROXY(SetTabAlt, index, value, host);
					}

					compositions::IGuiAltAction* GetTabAltAction(vint index)
					{
						return INVOKEGET_INTERFACE_PROXY(GetTabAltAction, index);
					}
				};

				class GuiScrollView_IStyleProvider : public virtual GuiControl_IStyleProvider, public virtual GuiScrollView::IStyleProvider
				{
				public:
					GuiScrollView_IStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleProvider(_proxy)
					{
					}

					static GuiScrollView::IStyleProvider* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiScrollView_IStyleProvider(_proxy);
					}

					GuiScroll::IStyleController* CreateHorizontalScrollStyle()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateHorizontalScrollStyle);
					}

					GuiScroll::IStyleController* CreateVerticalScrollStyle()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateVerticalScrollStyle);
					}

					vint GetDefaultScrollSize()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetDefaultScrollSize);
					}

					compositions::GuiGraphicsComposition* InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override
					{
						return INVOKEGET_INTERFACE_PROXY(InstallBackground, boundsComposition);
					}
				};

				class GuiWindow_IStyleController : public virtual GuiControl_IStyleController, public virtual GuiWindow::IStyleController
				{
				public:
					GuiWindow_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
					{
					}

					static GuiWindow::IStyleController* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiWindow_IStyleController(_proxy);
					}

					void AttachWindow(GuiWindow* _window)override
					{
						INVOKE_INTERFACE_PROXY(ActiveWindow, _window);
					}

					void InitializeNativeWindowProperties()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(InitializeNativeWindowProperties);
					}

					void SetSizeState(INativeWindow::WindowSizeState value)
					{
						INVOKE_INTERFACE_PROXY(SetSizeState, value);
					}

					bool GetMaximizedBox()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetMaximizedBox);
					}

					void SetMaximizedBox(bool visible)override
					{
						INVOKE_INTERFACE_PROXY(SetMaximizedBox, visible);
					}

					bool GetMinimizedBox()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetMinimizedBox);
					}

					void SetMinimizedBox(bool visible)override
					{
						INVOKE_INTERFACE_PROXY(SetMinimizedBox, visible);
					}

					bool GetBorder()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBorder);
					}

					void SetBorder(bool visible)override
					{
						INVOKE_INTERFACE_PROXY(SetBorder, visible);
					}

					bool GetSizeBox()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetSizeBox);
					}

					void SetSizeBox(bool visible)override
					{
						INVOKE_INTERFACE_PROXY(SetSizeBox, visible);
					}

					bool GetIconVisible()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetIconVisible);
					}

					void SetIconVisible(bool visible)override
					{
						INVOKE_INTERFACE_PROXY(SetIconVisible, visible);
					}

					bool GetTitleBar()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetTitleBar);
					}

					void SetTitleBar(bool visible)override
					{
						INVOKE_INTERFACE_PROXY(SetTitleBar, visible);
					}

					GuiWindow::IStyleController* CreateTooltipStyle()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateTooltipStyle);
					}

					GuiLabel::IStyleController* CreateShortcutKeyStyle()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateShortcutKeyStyle);
					}
				};

				class GuiListControl_IItemProviderCallback : public ValueInterfaceRoot, public virtual GuiListControl::IItemProviderCallback
				{
				public:
					GuiListControl_IItemProviderCallback(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<GuiListControl::IItemProviderCallback> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListControl_IItemProviderCallback(proxy);
					}

					void OnAttached(GuiListControl::IItemProvider* provider)override
					{
						INVOKE_INTERFACE_PROXY(OnAttached, provider);
					}

					void OnItemModified(vint start, vint count, vint newCount)override
					{
						INVOKE_INTERFACE_PROXY(OnItemModified, start, count, newCount);
					}
				};

				class GuiListControl_IItemPrimaryTextView : public ValueInterfaceRoot, public virtual GuiListControl::IItemPrimaryTextView
				{
				public:
					GuiListControl_IItemPrimaryTextView(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<GuiListControl::IItemPrimaryTextView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListControl_IItemPrimaryTextView(proxy);
					}

					WString GetPrimaryTextViewText(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetPrimaryTextViewText, itemIndex);
					}

					bool ContainsPrimaryText(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(ContainsPrimaryText, itemIndex);
					}
				};

				class GuiListControl_IItemBindingView : public ValueInterfaceRoot, public virtual GuiListControl::IItemBindingView
				{
				public:
					GuiListControl_IItemBindingView(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<GuiListControl::IItemBindingView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListControl_IItemBindingView(proxy);
					}

					description::Value GetBindingValue(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetBindingValue, itemIndex);
					}
				};

				class GuiListControl_IItemProvider : public ValueInterfaceRoot, public virtual GuiListControl::IItemProvider
				{
				public:
					GuiListControl_IItemProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static GuiListControl::IItemProvider* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListControl_IItemProvider(proxy);
					}

					bool AttachCallback(GuiListControl::IItemProviderCallback* value)override
					{
						return INVOKEGET_INTERFACE_PROXY(AttachCallback, value);
					}

					bool DetachCallback(GuiListControl::IItemProviderCallback* value)override
					{
						return INVOKEGET_INTERFACE_PROXY(DetachCallback, value);
					}

					vint Count()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(Count);
					}

					IDescriptable* RequestView(const WString& identifier)override
					{
						return INVOKEGET_INTERFACE_PROXY(RequestView, identifier);
					}

					void ReleaseView(IDescriptable* view)override
					{
						INVOKE_INTERFACE_PROXY(ReleaseView, view);
					}
				};

				class GuiListControl_IItemStyleController : public ValueInterfaceRoot, public virtual GuiListControl::IItemStyleController
				{
				public:
					GuiListControl_IItemStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static GuiListControl::IItemStyleController* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListControl_IItemStyleController(proxy);
					}

					GuiListControl::IItemStyleProvider* GetStyleProvider()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetStyleProvider);
					}

					vint GetItemStyleId()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetItemStyleId);
					}

					compositions::GuiBoundsComposition* GetBoundsComposition()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBoundsComposition);
					}

					bool IsCacheable()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(IsCacheable);
					}

					bool IsInstalled()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(IsInstalled);
					}

					void OnInstalled()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(OnInstalled);
					}

					void OnUninstalled()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(OnUninstalled);
					}
				};

				class GuiListControl_IItemStyleProvider : public ValueInterfaceRoot, public virtual GuiListControl::IItemStyleProvider
				{
				public:
					GuiListControl_IItemStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<GuiListControl::IItemStyleProvider> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListControl_IItemStyleProvider(proxy);
					}

					void AttachListControl(GuiListControl* value)override
					{
						INVOKE_INTERFACE_PROXY(AttachListControl, value);
					}

					void DetachListControl()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(DetachListControl);
					}

					vint GetItemStyleId(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetItemStyleId, itemIndex);
					}

					GuiListControl::IItemStyleController* CreateItemStyle(vint styleId)override
					{
						return INVOKEGET_INTERFACE_PROXY(CreateItemStyle, styleId);
					}

					void DestroyItemStyle(GuiListControl::IItemStyleController* style)override
					{
						INVOKE_INTERFACE_PROXY(DestroyItemStyle, style);
					}

					void Install(GuiListControl::IItemStyleController* style, vint itemIndex)override
					{
						INVOKE_INTERFACE_PROXY(Install, style, itemIndex);
					}

					void SetStyleIndex(GuiListControl::IItemStyleController* style, vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetStyleIndex, style, value);
					}
				};

				class GuiListControl_IItemArranger : public virtual GuiListControl_IItemProviderCallback, public virtual GuiListControl::IItemArranger
				{
				public:
					GuiListControl_IItemArranger(Ptr<IValueInterfaceProxy> _proxy)
						:GuiListControl_IItemProviderCallback(_proxy)
					{
					}

					static Ptr<GuiListControl::IItemArranger> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListControl_IItemArranger(proxy);
					}

					void AttachListControl(GuiListControl* value)override
					{
						INVOKE_INTERFACE_PROXY(AttachListControl, value);
					}

					void DetachListControl()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(DetachListControl);
					}

					GuiListControl::IItemArrangerCallback* GetCallback()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetCallback);
					}

					void SetCallback(GuiListControl::IItemArrangerCallback* value)override
					{
						INVOKE_INTERFACE_PROXY(SetCallback, value);
					}

					Size GetTotalSize()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetTotalSize);
					}

					GuiListControl::IItemStyleController* GetVisibleStyle(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetVisibleStyle, itemIndex);
					}

					vint GetVisibleIndex(GuiListControl::IItemStyleController* style)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetVisibleIndex, style);
					}

					void OnViewChanged(Rect bounds)override
					{
						INVOKE_INTERFACE_PROXY(OnViewChanged, bounds);
					}

					vint FindItem(vint itemIndex, compositions::KeyDirection key)override
					{
						return INVOKEGET_INTERFACE_PROXY(FindItem, itemIndex, key);
					}

					bool EnsureItemVisible(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(EnsureItemVisible, itemIndex);
					}
				};

				class GuiSelectableListControl_IItemStyleProvider : public virtual GuiListControl_IItemStyleProvider, public virtual GuiSelectableListControl::IItemStyleProvider
				{
				public:
					GuiSelectableListControl_IItemStyleProvider(Ptr<IValueInterfaceProxy> proxy)
						:GuiListControl_IItemStyleProvider(proxy)
					{
					}

					static Ptr<GuiSelectableListControl::IItemStyleProvider> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiSelectableListControl_IItemStyleProvider(proxy);
					}

					void SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetStyleSelected, style, value);
					}
				};

				class TextItemStyleProvider_ITextItemStyleProvider : public ValueInterfaceRoot, public virtual list::TextItemStyleProvider::ITextItemStyleProvider
				{
				public:
					TextItemStyleProvider_ITextItemStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static list::TextItemStyleProvider::ITextItemStyleProvider* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new TextItemStyleProvider_ITextItemStyleProvider(proxy);
					}

					GuiSelectableButton::IStyleController* CreateBackgroundStyleController()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateBackgroundStyleController);
					}

					GuiSelectableButton::IStyleController* CreateBulletStyleController()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateBulletStyleController);
					}

					Color GetTextColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetTextColor);
					}
				};

				class TextItemStyleProvider_ITextItemView : public virtual GuiListControl_IItemPrimaryTextView, public virtual list::TextItemStyleProvider::ITextItemView
				{
				public:
					TextItemStyleProvider_ITextItemView(Ptr<IValueInterfaceProxy> _proxy)
						:GuiListControl_IItemPrimaryTextView(_proxy)
					{
					}

					static Ptr<list::TextItemStyleProvider::ITextItemView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new TextItemStyleProvider_ITextItemView(proxy);
					}

					WString GetText(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetText, itemIndex);
					}

					bool GetChecked(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetChecked, itemIndex);
					}

					void SetCheckedSilently(vint itemIndex, bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetCheckedSilently, itemIndex, value);
					}
				};

				class GuiListViewBase_IStyleProvider : public virtual GuiScrollView_IStyleProvider, public virtual GuiListViewBase::IStyleProvider
				{
				public:
					GuiListViewBase_IStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleProvider(_proxy)
						,GuiScrollView_IStyleProvider(_proxy)
					{
					}

					static GuiListViewBase::IStyleProvider* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListViewBase_IStyleProvider(proxy);
					}

					GuiSelectableButton::IStyleController* CreateItemBackground()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateItemBackground);
					}

					GuiListViewColumnHeader::IStyleController* CreateColumnStyle()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateColumnStyle);
					}

					Color GetPrimaryTextColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetPrimaryTextColor);
					}

					Color GetSecondaryTextColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetSecondaryTextColor);
					}

					Color GetItemSeparatorColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetItemSeparatorColor);
					}
				};

				class ListViewItemStyleProvider_IListViewItemView : public virtual GuiListControl_IItemPrimaryTextView, public virtual list::ListViewItemStyleProvider::IListViewItemView
				{
				public:
					ListViewItemStyleProvider_IListViewItemView(Ptr<IValueInterfaceProxy> _proxy)
						:GuiListControl_IItemPrimaryTextView(_proxy)
					{
					}

					static Ptr<list::ListViewItemStyleProvider::IListViewItemView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new ListViewItemStyleProvider_IListViewItemView(proxy);
					}

					Ptr<GuiImageData> GetSmallImage(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetSmallImage, itemIndex);
					}

					Ptr<GuiImageData> GetLargeImage(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetLargeImage, itemIndex);
					}

					WString GetText(vint itemIndex)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetText, itemIndex);
					}

					WString GetSubItem(vint itemIndex, vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetSubItem, itemIndex, index);
					}

					vint GetDataColumnCount()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetDataColumnCount);
					}

					vint GetDataColumn(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetDataColumn, index);
					}

					vint GetColumnCount()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetColumnCount);
					}

					WString GetColumnText(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetColumnText, index);
					}
				};

				class ListViewItemStyleProvider_IListViewItemContent : public ValueInterfaceRoot, public virtual list::ListViewItemStyleProvider::IListViewItemContent
				{
				public:
					ListViewItemStyleProvider_IListViewItemContent(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static list::ListViewItemStyleProvider::IListViewItemContent* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new ListViewItemStyleProvider_IListViewItemContent(proxy);
					}

					compositions::GuiBoundsComposition* GetContentComposition()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetContentComposition);
					}

					compositions::GuiBoundsComposition* GetBackgroundDecorator()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBackgroundDecorator);
					}

					void Install(GuiListViewBase::IStyleProvider* styleProvider, list::ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override
					{
						INVOKE_INTERFACE_PROXY(Install, styleProvider, view, itemIndex);
					}

					void Uninstall()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(Uninstall);
					}
				};

				class ListViewItemStyleProvider_IListViewItemContentProvider : public ValueInterfaceRoot, public virtual list::ListViewItemStyleProvider::IListViewItemContentProvider
				{
				public:
					ListViewItemStyleProvider_IListViewItemContentProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::ListViewItemStyleProvider::IListViewItemContentProvider> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new ListViewItemStyleProvider_IListViewItemContentProvider(proxy);
					}

					compositions::IGuiAxis* CreatePreferredAxis()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreatePreferredAxis);
					}

					GuiListControl::IItemArranger* CreatePreferredArranger()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreatePreferredArranger);
					}

					list::ListViewItemStyleProvider::IListViewItemContent* CreateItemContent(const FontProperties& font)override
					{
						return INVOKEGET_INTERFACE_PROXY(CreateItemContent, font);
					}

					void AttachListControl(GuiListControl* value)override
					{
						INVOKE_INTERFACE_PROXY(AttachListControl, value);
					}

					void DetachListControl()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(DetachListControl);
					}
				};

				class ListViewColumnItemArranger_IColumnItemView : public ValueInterfaceRoot, public virtual list::ListViewColumnItemArranger::IColumnItemView
				{
				public:
					ListViewColumnItemArranger_IColumnItemView(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::ListViewColumnItemArranger::IColumnItemView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new ListViewColumnItemArranger_IColumnItemView(proxy);
					}

					bool AttachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override
					{
						return INVOKEGET_INTERFACE_PROXY(AttachCallback, value);
					}

					bool DetachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override
					{
						return INVOKEGET_INTERFACE_PROXY(DetachCallback, value);
					}

					vint GetColumnCount()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetColumnCount);
					}

					WString GetColumnText(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetColumnText, index);
					}

					vint GetColumnSize(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetColumnSize, index);
					}

					void SetColumnSize(vint index, vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetColumnSize, index, value);
					}

					GuiMenu* GetDropdownPopup(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetDropdownPopup, index);
					}

					GuiListViewColumnHeader::ColumnSortingState GetSortingState(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetSortingState, index);
					}
				};

				class GuiMenuButton_IStyleController : public virtual GuiSelectableButton_IStyleController, public virtual GuiMenuButton::IStyleController
				{
				public:
					GuiMenuButton_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
						,GuiButton_IStyleController(_proxy)
						,GuiSelectableButton_IStyleController(_proxy)
					{
					}

					static GuiMenuButton::IStyleController* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiMenuButton_IStyleController(proxy);
					}

					GuiMenu::IStyleController* CreateSubMenuStyleController()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateSubMenuStyleController);
					}

					void SetSubMenuExisting(bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetSubMenuExisting, value);
					}

					void SetSubMenuOpening(bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetSubMenuOpening, value);
					}

					GuiButton* GetSubMenuHost()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetSubMenuHost);
					}

					void SetImage(Ptr<GuiImageData> value)override
					{
						INVOKE_INTERFACE_PROXY(SetImage, value);
					}

					void SetShortcutText(const WString& value)override
					{
						INVOKE_INTERFACE_PROXY(SetShortcutText, value);
					}
				};

				class GuiListViewColumnHeader_IStyleController : public virtual GuiMenuButton_IStyleController, public virtual GuiListViewColumnHeader::IStyleController
				{
				public:
					GuiListViewColumnHeader_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
						,GuiButton_IStyleController(_proxy)
						,GuiSelectableButton_IStyleController(_proxy)
						,GuiMenuButton_IStyleController(_proxy)
					{
					}

					static GuiListViewColumnHeader::IStyleController* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiListViewColumnHeader_IStyleController(proxy);
					}

					void SetColumnSortingState(GuiListViewColumnHeader::ColumnSortingState value)override
					{
						INVOKE_INTERFACE_PROXY(SetColumnSortingState, value);
					}
				};

				class tree_INodeProvider : public ValueInterfaceRoot, public virtual tree::INodeProvider
				{
				public:
					tree_INodeProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<tree::INodeProvider> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_INodeProvider(proxy);
					}

					bool GetExpanding()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetExpanding);
					}

					void SetExpanding(bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetExpanding, value);
					}

					vint CalculateTotalVisibleNodes()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CalculateTotalVisibleNodes);
					}

					vint GetChildCount()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetChildCount);
					}

					tree::INodeProvider* GetParent()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetParent);
					}

					tree::INodeProvider* GetChild(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetChild, index);
					}

					void Increase()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(Increase);
					}

					void Release()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(Release);
					}
				};

				class tree_INodeRootProvider : public ValueInterfaceRoot, public virtual tree::INodeRootProvider
				{
				public:
					tree_INodeRootProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<tree::INodeRootProvider> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_INodeRootProvider(proxy);
					}

					tree::INodeProvider* GetRootNode()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetRootNode);
					}

					bool CanGetNodeByVisibleIndex()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CanGetNodeByVisibleIndex);
					}

					tree::INodeProvider* GetNodeByVisibleIndex(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetNodeByVisibleIndex, index);
					}

					bool AttachCallback(tree::INodeProviderCallback* value)override
					{
						return INVOKEGET_INTERFACE_PROXY(AttachCallback, value);
					}

					bool DetachCallback(tree::INodeProviderCallback* value)override
					{
						return INVOKEGET_INTERFACE_PROXY(DetachCallback, value);
					}

					IDescriptable* RequestView(const WString& identifier)override
					{
						return INVOKEGET_INTERFACE_PROXY(RequestView, identifier);
					}

					void ReleaseView(IDescriptable* view)override
					{
						INVOKE_INTERFACE_PROXY(ReleaseView, view);
					}
				};

				class tree_INodeItemView : public virtual GuiListControl_IItemPrimaryTextView, public virtual tree::INodeItemView
				{
				public:
					tree_INodeItemView(Ptr<IValueInterfaceProxy> _proxy)
						:GuiListControl_IItemPrimaryTextView(_proxy)
					{
					}

					static Ptr<tree::INodeItemView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_INodeItemView(proxy);
					}

					tree::INodeProvider* RequestNode(vint index)override
					{
						return INVOKEGET_INTERFACE_PROXY(RequestNode, index);
					}

					void ReleaseNode(tree::INodeProvider* node)override
					{
						INVOKE_INTERFACE_PROXY(ReleaseNode, node);
					}

					vint CalculateNodeVisibilityIndex(tree::INodeProvider* node)override
					{
						return INVOKEGET_INTERFACE_PROXY(CalculateNodeVisibilityIndex, node);
					}
				};

				class tree_INodeItemPrimaryTextView : public ValueInterfaceRoot, public virtual tree::INodeItemPrimaryTextView
				{
				public:
					tree_INodeItemPrimaryTextView(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<tree::INodeItemPrimaryTextView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_INodeItemPrimaryTextView(proxy);
					}

					WString GetPrimaryTextViewText(tree::INodeProvider* node)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetPrimaryTextViewText, node);
					}
				};

				class tree_INodeItemBindingView: public ValueInterfaceRoot, public virtual tree::INodeItemBindingView
				{
				public:
					tree_INodeItemBindingView(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<tree::INodeItemBindingView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_INodeItemBindingView(proxy);
					}

					description::Value GetBindingValue(tree::INodeProvider* node)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetBindingValue, node);
					}
				};

				class tree_INodeItemStyleController: public virtual GuiListControl_IItemStyleController, public virtual tree::INodeItemStyleController
				{
				public:
					tree_INodeItemStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiListControl_IItemStyleController(_proxy)
					{
					}

					static tree::INodeItemStyleController* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_INodeItemStyleController(proxy);
					}

					tree::INodeItemStyleProvider* GetNodeStyleProvider()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetNodeStyleProvider);
					}
				};

				class tree_INodeItemStyleProvider : public ValueInterfaceRoot, public virtual tree::INodeItemStyleProvider
				{
				public:
					tree_INodeItemStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<tree::INodeItemStyleProvider> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_INodeItemStyleProvider(proxy);
					}

					void BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)override
					{
						INVOKE_INTERFACE_PROXY(BindItemStyleProvider, styleProvider);
					}

					GuiListControl::IItemStyleProvider* GetBindedItemStyleProvider()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBindedItemStyleProvider);
					}

					void AttachListControl(GuiListControl* value)override
					{
						INVOKE_INTERFACE_PROXY(AttachListControl, value);
					}

					void DetachListControl()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(DetachListControl);
					}

					vint GetItemStyleId(tree::INodeProvider* node)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetItemStyleId, node);
					}

					tree::INodeItemStyleController* CreateItemStyle(vint styleId)override
					{
						return INVOKEGET_INTERFACE_PROXY(CreateItemStyle, styleId);
					}

					void DestroyItemStyle(tree::INodeItemStyleController* style)override
					{
						INVOKE_INTERFACE_PROXY(DestroyItemStyle, style);
					}

					void Install(tree::INodeItemStyleController* style, tree::INodeProvider* node, vint itemIndex)override
					{
						INVOKE_INTERFACE_PROXY(Install, style, node, itemIndex);
					}

					void SetStyleIndex(tree::INodeItemStyleController* style, vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetStyleIndex, style, value);
					}

					void SetStyleSelected(tree::INodeItemStyleController* style, bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetStyleSelected, style, value);
					}
				};

				class tree_IMemoryNodeData : public ValueInterfaceRoot, public virtual tree::IMemoryNodeData
				{
				public:
					tree_IMemoryNodeData(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<tree::IMemoryNodeData> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_IMemoryNodeData(proxy);
					}
				};

				class tree_ITreeViewItemView : public virtual tree_INodeItemPrimaryTextView, public virtual tree::ITreeViewItemView
				{
				public:
					tree_ITreeViewItemView(Ptr<IValueInterfaceProxy> proxy)
						:tree_INodeItemPrimaryTextView(proxy)
					{
					}

					static Ptr<tree::ITreeViewItemView> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new tree_ITreeViewItemView(proxy);
					}

					Ptr<GuiImageData> GetNodeImage(tree::INodeProvider* node)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetNodeImage, node);
					}

					WString GetNodeText(tree::INodeProvider* node)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetNodeText, node);
					}
				};

				class GuiVirtualTreeView_IStyleProvider : public virtual GuiScrollView_IStyleProvider, public virtual GuiVirtualTreeView::IStyleProvider
				{
				public:
					GuiVirtualTreeView_IStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleProvider(_proxy)
						,GuiScrollView_IStyleProvider(_proxy)
					{
					}

					static GuiVirtualTreeView::IStyleProvider* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiVirtualTreeView_IStyleProvider(proxy);
					}

					GuiSelectableButton::IStyleController* CreateItemBackground()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateItemBackground);
					}

					GuiSelectableButton::IStyleController* CreateItemExpandingDecorator()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateItemExpandingDecorator);
					}

					Color GetTextColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetTextColor);
					}
				};

				class GuiComboBoxBase_IStyleController : public virtual GuiMenuButton_IStyleController, public virtual GuiComboBoxBase::IStyleController
				{
				public:
					GuiComboBoxBase_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
						,GuiButton_IStyleController(_proxy)
						,GuiSelectableButton_IStyleController(_proxy)
						,GuiMenuButton_IStyleController(_proxy)
					{
					}

					static GuiComboBoxBase::IStyleController* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiComboBoxBase_IStyleController(proxy);
					}

					void SetCommandExecutor(GuiComboBoxBase::ICommandExecutor* value)override
					{
						INVOKE_INTERFACE_PROXY(SetCommandExecutor, value);
					}

					void OnItemSelected()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(OnItemSelected);
					}
				};

				class GuiSinglelineTextBox_IStyleProvider : public virtual GuiControl_IStyleProvider, public virtual GuiSinglelineTextBox::IStyleProvider
				{
				public:
					GuiSinglelineTextBox_IStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleProvider(_proxy)
					{
					}

					static GuiSinglelineTextBox::IStyleProvider* Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiSinglelineTextBox_IStyleProvider(proxy);
					}

					compositions::GuiGraphicsComposition* InstallBackground(compositions::GuiBoundsComposition* background)override
					{
						return INVOKEGET_INTERFACE_PROXY(InstallBackground, background);
					}
				};

				class list_IDataVisualizerFactory : public ValueInterfaceRoot, public virtual list::IDataVisualizerFactory
				{
				public:
					list_IDataVisualizerFactory(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IDataVisualizerFactory> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IDataVisualizerFactory(_proxy);
					}

					Ptr<list::IDataVisualizer> CreateVisualizer(const FontProperties& font, GuiListViewBase::IStyleProvider* styleProvider)override
					{
						return INVOKEGET_INTERFACE_PROXY(CreateVisualizer, font, styleProvider);
					}
				};

				class list_IDataVisualizer : public ValueInterfaceRoot, public virtual list::IDataVisualizer
				{
				public:
					list_IDataVisualizer(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IDataVisualizer> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IDataVisualizer(_proxy);
					}

					list::IDataVisualizerFactory* GetFactory()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetFactory);
					}

					compositions::GuiBoundsComposition* GetBoundsComposition()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBoundsComposition);
					}

					void BeforeVisualizeCell(list::IDataProvider* dataProvider, vint row, vint column)override
					{
						INVOKE_INTERFACE_PROXY(dataProvider, row, column);
					}

					list::IDataVisualizer* GetDecoratedDataVisualizer()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetDecoratedDataVisualizer);
					}

					void SetSelected(bool value)override
					{
						INVOKE_INTERFACE_PROXY(SetSelected, value);
					}
				};

				class list_IDataEditorFactory : public ValueInterfaceRoot, public virtual list::IDataEditorFactory
				{
				public:
					list_IDataEditorFactory(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IDataEditorFactory> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IDataEditorFactory(_proxy);
					}

					Ptr<list::IDataEditor> CreateEditor(list::IDataEditorCallback* callback)
					{
						return INVOKEGET_INTERFACE_PROXY(CreateEditor, callback);
					}
				};

				class list_IDataEditor : public ValueInterfaceRoot, public virtual list::IDataEditor
				{
				public:
					list_IDataEditor(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IDataEditor> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IDataEditor(_proxy);
					}

					list::IDataEditorFactory* GetFactory()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetFactory);
					}

					compositions::GuiBoundsComposition* GetBoundsComposition()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBoundsComposition);
					}

					void BeforeEditCell(list::IDataProvider* dataProvider, vint row, vint column)override
					{
						INVOKE_INTERFACE_PROXY(BeforeEditCell, dataProvider, row, column);
					}

					void ReinstallEditor()override
					{
						INVOKE_INTERFACE_PROXY_NOPARAMS(ReinstallEditor);
					}
				};

				class list_IDataProvider : public ValueInterfaceRoot, public virtual list::IDataProvider
				{
				public:
					list_IDataProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IDataProvider> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IDataProvider(_proxy);
					}

					void SetCommandExecutor(list::IDataProviderCommandExecutor* value)override
					{
						INVOKE_INTERFACE_PROXY(SetCommandExecutor, value);
					}

					vint GetColumnCount()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetColumnCount);
					}

					WString GetColumnText(vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetColumnText, column);
					}

					vint GetColumnSize(vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetColumnSize, column);
					}

					void SetColumnSize(vint column, vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetColumnSize, column, value);
					}

					GuiMenu* GetColumnPopup(vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetColumnPopup, column);
					}

					bool IsColumnSortable(vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(IsColumnSortable, column);
					}

					void SortByColumn(vint column, bool ascending)override
					{
						INVOKE_INTERFACE_PROXY(SortByColumn, column, ascending);
					}

					vint GetSortedColumn()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetSortedColumn);
					}

					bool IsSortOrderAscending()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(IsSortOrderAscending);
					}

					vint GetRowCount()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetRowCount);
					}

					Ptr<GuiImageData> GetRowLargeImage(vint row)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetRowLargeImage, row);
					}

					Ptr<GuiImageData> GetRowSmallImage(vint row)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetRowSmallImage, row);
					}

					vint GetCellSpan(vint row, vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetCellSpan, row, column);
					}

					WString GetCellText(vint row, vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetCellText, row, column);
					}

					list::IDataVisualizerFactory* GetCellDataVisualizerFactory(vint row, vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetCellDataVisualizerFactory, row, column);
					}

					void VisualizeCell(vint row, vint column, list::IDataVisualizer* dataVisualizer)override
					{
						INVOKE_INTERFACE_PROXY(VisualizeCell, row, column, dataVisualizer);
					}

					list::IDataEditorFactory* GetCellDataEditorFactory(vint row, vint column)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetCellDataEditorFactory, row, column);
					}

					void BeforeEditCell(vint row, vint column, list::IDataEditor* dataEditor)override
					{
						INVOKE_INTERFACE_PROXY(BeforeEditCell, row, column, dataEditor);
					}

					void SaveCellData(vint row, vint column, list::IDataEditor* dataEditor)override
					{
						INVOKE_INTERFACE_PROXY(SaveCellData, row, column, dataEditor);
					}
				};

				class list_IStructuredDataFilter : public ValueInterfaceRoot, public virtual list::IStructuredDataFilter
				{
				public:
					list_IStructuredDataFilter(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IStructuredDataFilter> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IStructuredDataFilter(_proxy);
					}

					void SetCommandExecutor(list::IStructuredDataFilterCommandExecutor* value)override
					{
						INVOKE_INTERFACE_PROXY(SetCommandExecutor, value);
					}

					bool Filter(vint row)override
					{
						return INVOKEGET_INTERFACE_PROXY(Filter, row);
					}
				};

				class list_IStructuredDataSorter : public ValueInterfaceRoot, public virtual list::IStructuredDataSorter
				{
				public:
					list_IStructuredDataSorter(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IStructuredDataSorter> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IStructuredDataSorter(_proxy);
					}

					vint Compare(vint row1, vint row2)override
					{
						return INVOKEGET_INTERFACE_PROXY(Compare, row1, row2);
					}
				};

				class list_IStructuredColumnProvider : public ValueInterfaceRoot, public virtual list::IStructuredColumnProvider
				{
				public:
					list_IStructuredColumnProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IStructuredColumnProvider> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IStructuredColumnProvider(_proxy);
					}

					WString GetText()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetText);
					}

					vint GetSize()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetSize);
					}

					void SetSize(vint value)override
					{
						INVOKE_INTERFACE_PROXY(SetSize, value);
					}

					GuiListViewColumnHeader::ColumnSortingState GetSortingState()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetSortingState);
					}

					void SetSortingState(GuiListViewColumnHeader::ColumnSortingState value)override
					{
						INVOKE_INTERFACE_PROXY(SetSortingState, value);
					}

					GuiMenu* GetPopup()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetPopup);
					}

					Ptr<list::IStructuredDataFilter> GetInherentFilter()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetInherentFilter);
					}

					Ptr<list::IStructuredDataSorter> GetInherentSorter()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetInherentSorter);
					}

					WString GetCellText(vint row)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetCellText, row);
					}

					list::IDataVisualizerFactory* GetCellDataVisualizerFactory(vint row)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetCellDataVisualizerFactory, row);
					}

					void VisualizeCell(vint row, list::IDataVisualizer* dataVisualizer)override
					{
						INVOKE_INTERFACE_PROXY(VisualizeCell, row, dataVisualizer);
					}

					list::IDataEditorFactory* GetCellDataEditorFactory(vint row)override
					{
						return INVOKEGET_INTERFACE_PROXY(GetCellDataEditorFactory, row);
					}

					void BeforeEditCell(vint row, list::IDataEditor* dataEditor)override
					{
						INVOKE_INTERFACE_PROXY(BeforeEditCell, row, dataEditor);
					}

					void SaveCellData(vint row, list::IDataEditor* dataEditor)override
					{
						INVOKE_INTERFACE_PROXY(SaveCellData, row, dataEditor);
					}
				};

				class list_IStructuredDataProvider : public ValueInterfaceRoot, public virtual list::IStructuredDataProvider
				{
				public:
					list_IStructuredDataProvider(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<list::IStructuredDataProvider> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new list_IStructuredDataProvider(_proxy);
					}

					void SetCommandExecutor(list::IDataProviderCommandExecutor* value)
					{
						INVOKE_INTERFACE_PROXY(SetCommandExecutor, value);
					}

					vint GetColumnCount()
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetColumnCount);
					}

					vint GetRowCount()
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetRowCount);
					}

					list::IStructuredColumnProvider* GetColumn(vint column)
					{
						return INVOKEGET_INTERFACE_PROXY(GetColumn, column);
					}

					Ptr<GuiImageData> GetRowLargeImage(vint row)
					{
						return INVOKEGET_INTERFACE_PROXY(GetRowLargeImage, row);
					}

					Ptr<GuiImageData> GetRowSmallImage(vint row)
					{
						return INVOKEGET_INTERFACE_PROXY(GetRowSmallImage, row);
					}
				};

				class GuiDatePicker_IStyleProvider : public GuiControl_IStyleProvider, public virtual GuiDatePicker::IStyleProvider
				{
				public:
					GuiDatePicker_IStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleProvider(_proxy)
					{
					}

					static GuiDatePicker::IStyleProvider* Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiDatePicker_IStyleProvider(_proxy);
					}

					GuiSelectableButton::IStyleController* CreateDateButtonStyle()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateDateButtonStyle);
					}

					GuiTextList* CreateTextList()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateTextList);
					}

					GuiComboBoxListControl::IStyleController* CreateComboBoxStyle()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(CreateComboBoxStyle);
					}

					Color GetBackgroundColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBackgroundColor);
					}

					Color GetPrimaryTextColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetPrimaryTextColor);
					}

					Color GetSecondaryTextColor()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetSecondaryTextColor);
					}
				};

				class GuiDocumentViewer_IStyleProvider : public GuiScrollView_IStyleProvider, public virtual GuiDocumentViewer::IStyleProvider
				{
				public:
					GuiDocumentViewer_IStyleProvider(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleProvider(_proxy)
						,GuiScrollView_IStyleProvider(_proxy)
					{
					}

					static Ptr<GuiDocumentViewer::IStyleProvider> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiDocumentViewer_IStyleProvider(_proxy);
					}

					Ptr<DocumentModel> GetBaselineDocument()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBaselineDocument);
					}
				};

				class GuiDocumentLabel_IStyleController : public GuiControl_IStyleController, public virtual GuiDocumentLabel::IStyleController
				{
				public:
					GuiDocumentLabel_IStyleController(Ptr<IValueInterfaceProxy> _proxy)
						:GuiControl_IStyleController(_proxy)
					{
					}

					static Ptr<GuiDocumentLabel::IStyleController> Create(Ptr<IValueInterfaceProxy> _proxy)
					{
						return new GuiDocumentLabel_IStyleController(_proxy);
					}

					Ptr<DocumentModel> GetBaselineDocument()override
					{
						return INVOKEGET_INTERFACE_PROXY_NOPARAMS(GetBaselineDocument);
					}
				};
			}
#pragma warning(pop)

/***********************************************************************
Type Loader
***********************************************************************/

#endif

			extern bool						LoadGuiControlTypes();
		}
	}
}

#endif

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Basic

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIREFLECTIOTEMPLATES
#define VCZH_PRESENTATION_REFLECTION_GUIREFLECTIOTEMPLATES


namespace vl
{
	namespace reflection
	{
		namespace description
		{

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONTEMPLATES_TYPELIST(F)\
			F(presentation::templates::BoolOption)\
			F(presentation::templates::GuiTemplate)\
			F(presentation::templates::GuiTemplate::IFactory)\
			F(presentation::templates::GuiControlTemplate)\
			F(presentation::templates::GuiLabelTemplate)\
			F(presentation::templates::GuiSinglelineTextBoxTemplate)\
			F(presentation::templates::GuiDocumentLabelTemplate)\
			F(presentation::templates::GuiMultilineTextBoxTemplate)\
			F(presentation::templates::GuiDocumentViewerTemplate)\
			F(presentation::templates::GuiMenuTemplate)\
			F(presentation::templates::GuiWindowTemplate)\
			F(presentation::templates::GuiButtonTemplate)\
			F(presentation::templates::GuiSelectableButtonTemplate)\
			F(presentation::templates::GuiToolstripButtonTemplate)\
			F(presentation::templates::GuiListViewColumnHeaderTemplate)\
			F(presentation::templates::GuiComboBoxTemplate)\
			F(presentation::templates::GuiDatePickerTemplate)\
			F(presentation::templates::GuiDateComboBoxTemplate)\
			F(presentation::templates::GuiScrollTemplate)\
			F(presentation::templates::GuiScrollViewTemplate)\
			F(presentation::templates::GuiTextListTemplate)\
			F(presentation::templates::GuiListViewTemplate)\
			F(presentation::templates::GuiTreeViewTemplate)\
			F(presentation::templates::GuiTabTemplate)\
			F(presentation::templates::GuiListItemTemplate)\
			F(presentation::templates::GuiTreeItemTemplate)\
			F(presentation::templates::GuiGridVisualizerTemplate)\
			F(presentation::templates::GuiGridEditorTemplate)\
			F(presentation::templates::GuiControlTemplate_StyleProvider)\
			F(presentation::templates::GuiLabelTemplate_StyleProvider)\
			F(presentation::templates::GuiSinglelineTextBoxTemplate_StyleProvider)\
			F(presentation::templates::GuiDocumentLabelTemplate_StyleProvider)\
			F(presentation::templates::GuiMultilineTextBoxTemplate_StyleProvider)\
			F(presentation::templates::GuiDocumentViewerTemplate_StyleProvider)\
			F(presentation::templates::GuiMenuTemplate_StyleProvider)\
			F(presentation::templates::GuiWindowTemplate_StyleProvider)\
			F(presentation::templates::GuiButtonTemplate_StyleProvider)\
			F(presentation::templates::GuiSelectableButtonTemplate_StyleProvider)\
			F(presentation::templates::GuiToolstripButtonTemplate_StyleProvider)\
			F(presentation::templates::GuiListViewColumnHeaderTemplate_StyleProvider)\
			F(presentation::templates::GuiComboBoxTemplate_StyleProvider)\
			F(presentation::templates::GuiDatePickerTemplate_StyleProvider)\
			F(presentation::templates::GuiDateComboBoxTemplate_StyleProvider)\
			F(presentation::templates::GuiScrollTemplate_StyleProvider)\
			F(presentation::templates::GuiScrollViewTemplate_StyleProvider)\
			F(presentation::templates::GuiTextListTemplate_StyleProvider)\
			F(presentation::templates::GuiListViewTemplate_StyleProvider)\
			F(presentation::templates::GuiTreeViewTemplate_StyleProvider)\
			F(presentation::templates::GuiTabTemplate_StyleProvider)\
			F(presentation::templates::GuiListItemTemplate_ItemStyleController)\
			F(presentation::templates::GuiListItemTemplate_ItemStyleProvider)\
			F(presentation::templates::GuiTreeItemTemplate_ItemStyleProvider)\
			F(presentation::templates::GuiBindableDataVisualizer)\
			F(presentation::templates::GuiBindableDataVisualizer::Factory)\
			F(presentation::templates::GuiBindableDataVisualizer::DecoratedFactory)\
			F(presentation::templates::GuiBindableDataEditor)\
			F(presentation::templates::GuiBindableDataEditor::Factory)\

			GUIREFLECTIONTEMPLATES_TYPELIST(DECL_TYPE_INFO)

/***********************************************************************
Interface Proxy
***********************************************************************/

#pragma warning(push)
#pragma warning(disable:4250)
			namespace interface_proxy
			{
				using namespace presentation;
				using namespace presentation::templates;

				class GuiTemplate_IFactory : public ValueInterfaceRoot, public virtual GuiTemplate::IFactory
				{
				public:
					GuiTemplate_IFactory(Ptr<IValueInterfaceProxy> _proxy)
						:ValueInterfaceRoot(_proxy)
					{
					}

					static Ptr<GuiTemplate::IFactory> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new GuiTemplate_IFactory(proxy);
					}

					GuiTemplate* CreateTemplate(const Value& viewModel)override
					{
						return INVOKEGET_INTERFACE_PROXY(CreateTemplate, viewModel);
					}
				};
			}
#pragma warning(pop)

/***********************************************************************
Type Loader
***********************************************************************/

#endif

			extern bool						LoadGuiTemplateTypes();
		}
	}
}

#endif

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONEVENTS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Events

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONEVENTS
#define VCZH_PRESENTATION_REFLECTION_GUIREFLECTIONEVENTS


namespace vl
{
	namespace reflection
	{
		namespace description
		{

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONEVENT_TYPELIST(F)\
			F(presentation::compositions::GuiEventArgs)\
			F(presentation::compositions::GuiRequestEventArgs)\
			F(presentation::compositions::GuiKeyEventArgs)\
			F(presentation::compositions::GuiCharEventArgs)\
			F(presentation::compositions::GuiMouseEventArgs)\
			F(presentation::compositions::GuiItemEventArgs)\
			F(presentation::compositions::GuiItemMouseEventArgs)\
			F(presentation::compositions::GuiNodeEventArgs)\
			F(presentation::compositions::GuiNodeMouseEventArgs)\

			GUIREFLECTIONEVENT_TYPELIST(DECL_TYPE_INFO)

/***********************************************************************
GuiEventInfoImpl
***********************************************************************/

			template<typename T>
			class GuiEventInfoImpl : public EventInfoImpl
			{
				using GuiGraphicsComposition = presentation::compositions::GuiGraphicsComposition;

				template<typename U>
				using GuiGraphicsEvent = presentation::compositions::GuiGraphicsEvent<U>;
			protected:
				typedef Func<GuiGraphicsEvent<T>*(DescriptableObject*, bool)>		EventRetriverFunction;

				EventRetriverFunction				eventRetriver;

				void AttachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)override
				{
					if(thisObject)
					{
						if(EventHandlerImpl* handlerImpl=dynamic_cast<EventHandlerImpl*>(eventHandler))
						{
							GuiGraphicsEvent<T>* eventObject=eventRetriver(thisObject, true);
							if(eventObject)
							{
								auto handler=eventObject->AttachLambda(
									[=](GuiGraphicsComposition* sender, T& arguments)
									{
										Value senderObject = BoxValue<GuiGraphicsComposition*>(sender, Description<GuiGraphicsComposition>::GetAssociatedTypeDescriptor());
										Value argumentsObject = BoxValue<T*>(&arguments, Description<T>::GetAssociatedTypeDescriptor());

										collections::Array<Value> eventArgs(2);
										eventArgs[0] = senderObject;
										eventArgs[1] = argumentsObject;
										eventHandler->Invoke(Value::From(thisObject), eventArgs);
									});
								handlerImpl->SetDescriptableTag(handler);
							}
						}
					}
				}

				void DetachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)override
				{
					if(thisObject)
					{
						if(EventHandlerImpl* handlerImpl=dynamic_cast<EventHandlerImpl*>(eventHandler))
						{
							GuiGraphicsEvent<T>* eventObject=eventRetriver(thisObject, false);
							if(eventObject)
							{
								auto handler=handlerImpl->GetDescriptableTag().Cast<typename GuiGraphicsEvent<T>::IHandler>();
								if(handler)
								{
									eventObject->Detach(handler);
								}
							}
						}
					}
				}

				void InvokeInternal(DescriptableObject* thisObject, collections::Array<Value>& arguments)override
				{
					if(thisObject)
					{
						GuiGraphicsEvent<T>* eventObject=eventRetriver(thisObject, false);
						if(eventObject)
						{
							T* value=UnboxValue<T*>(arguments[1], Description<T>::GetAssociatedTypeDescriptor());
							eventObject->Execute(*value);
						}
					}
				}

				Ptr<ITypeInfo> GetHandlerTypeInternal()override
				{
					return TypeInfoRetriver<Func<void(GuiGraphicsComposition*, T*)>>::CreateTypeInfo();
				}
			public:
				GuiEventInfoImpl(ITypeDescriptor* _ownerTypeDescriptor, const WString& _name, const EventRetriverFunction& _eventRetriver)
					:EventInfoImpl(_ownerTypeDescriptor, _name)
					,eventRetriver(_eventRetriver)
				{
				}

				~GuiEventInfoImpl()
				{
				}
			};

			template<typename T>
			struct GuiEventArgumentTypeRetriver
			{
				typedef vint								Type;
			};

			template<typename TClass, typename TEvent>
			struct GuiEventArgumentTypeRetriver<TEvent TClass::*>
			{
				typedef typename TEvent::ArgumentType		Type;
			};

/***********************************************************************
Macros
***********************************************************************/

#define CLASS_MEMBER_GUIEVENT(EVENTNAME)\
			AddEvent(\
				new GuiEventInfoImpl<GuiEventArgumentTypeRetriver<decltype(&ClassType::EVENTNAME)>::Type>(\
					this,\
					L ## #EVENTNAME,\
					[](DescriptableObject* thisObject, bool addEventHandler){\
						return &dynamic_cast<ClassType*>(thisObject)->EVENTNAME;\
					}\
				)\
			);\

#define CLASS_MEMBER_GUIEVENT_COMPOSITION(EVENTNAME)\
			AddEvent(\
				new GuiEventInfoImpl<GuiEventArgumentTypeRetriver<decltype(&GuiGraphicsEventReceiver::EVENTNAME)>::Type>(\
					this,\
					L ## #EVENTNAME,\
					[](DescriptableObject* thisObject, bool addEventHandler){\
						GuiGraphicsComposition* composition=dynamic_cast<GuiGraphicsComposition*>(thisObject);\
						if(!addEventHandler && !composition->HasEventReceiver())\
						{\
							return (GuiGraphicsEvent<GuiEventArgumentTypeRetriver<decltype(&GuiGraphicsEventReceiver::EVENTNAME)>::Type>*)0;\
						}\
						return &composition->GetEventReceiver()->EVENTNAME;\
					}\
				)\
			);\

#define CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(PROPERTYNAME)\
			CLASS_MEMBER_GUIEVENT(PROPERTYNAME##Changed)\
			CLASS_MEMBER_PROPERTY_EVENT_FAST(PROPERTYNAME, PROPERTYNAME##Changed)\

#define CLASS_MEMBER_PROPERTY_GUIEVENT_READONLY_FAST(PROPERTYNAME)\
			CLASS_MEMBER_GUIEVENT(PROPERTYNAME##Changed)\
			CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(PROPERTYNAME, PROPERTYNAME##Changed)\

#define GUIEVENT_HANDLER_PARAMETERS {L"sender", L"arguments"}

#define CLASS_MEMBER_GUIEVENT_HANDLER(FUNCTIONNAME, ARGUMENTTYPE)\
			CLASS_MEMBER_EXTERNALMETHOD(\
				FUNCTIONNAME,\
				GUIEVENT_HANDLER_PARAMETERS,\
				void(ClassType::*)(vl::presentation::compositions::GuiGraphicsComposition*, ARGUMENTTYPE*),\
				[](ClassType* owner, vl::presentation::compositions::GuiGraphicsComposition* sender, ARGUMENTTYPE* arguments)\
				{\
					owner->FUNCTIONNAME(sender, *arguments);\
				})\

/***********************************************************************
Type Loader
***********************************************************************/

#endif

			extern bool						LoadGuiEventTypes();
		}
	}
}

#endif

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Query

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY


namespace vl
{
	namespace presentation
	{
		extern void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& input, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ApplyStyle(Ptr<GuiInstanceStyle> style, Ptr<GuiConstructorRepr> ctor);
		extern void GuiIqPrint(Ptr<GuiIqQuery> query, stream::StreamWriter& writer);
	}
}

#endif

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWCODEGEN.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Schema Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN


namespace vl
{
	namespace presentation
	{
		namespace types
		{
			struct PropertyResolving
			{
				IGuiInstanceLoader*								loader = nullptr;
				IGuiInstanceLoader::PropertyInfo				propertyInfo;
				Ptr<GuiInstancePropertyInfo>					info;
			};

			typedef collections::Dictionary<GlobalStringKey, IGuiInstanceLoader::TypeInfo>		VariableTypeInfoMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<description::ITypeInfo>>		TypeOverrideMap;
			typedef collections::Dictionary<GuiValueRepr*, PropertyResolving>					PropertyResolvingMap;
			typedef collections::List<WString>													ErrorList;

			struct ResolvingResult
			{
				VariableTypeInfoMap								typeInfos;
				TypeOverrideMap									typeOverrides;
				PropertyResolvingMap							propertyResolvings;
			};
		}
		extern workflow::analyzer::WfLexicalScopeManager*		Workflow_GetSharedManager();
		

/***********************************************************************
WorkflowCompiler (Parser)
***********************************************************************/
		
		extern Ptr<workflow::WfExpression>						Workflow_ParseExpression(const WString& code, types::ErrorList& errors);
		extern Ptr<workflow::WfStatement>						Workflow_ParseStatement(const WString& code, types::ErrorList& errors);
		extern WString											Workflow_ModuleToString(Ptr<workflow::WfModule> module);

/***********************************************************************
WorkflowCompiler (Installation)
***********************************************************************/

		extern Ptr<workflow::WfStatement>						Workflow_InstallUriProperty(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, const WString& protocol, const WString& path);
		extern Ptr<workflow::WfStatement>						Workflow_InstallBindProperty(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, Ptr<workflow::WfExpression> bindExpression);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalProperty(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, Ptr<workflow::WfExpression> evalExpression);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvent(GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& handlerName);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalEvent(GlobalStringKey variableName, description::IEventInfo* eventInfo, Ptr<workflow::WfStatement> evalStatement);

/***********************************************************************
WorkflowCompiler (Compile)
***********************************************************************/

		extern Ptr<workflow::WfModule>							Workflow_CreateEmptyModule(Ptr<GuiInstanceContext> context);
		extern Ptr<workflow::WfModule>							Workflow_CreateModuleWithInitFunction(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, Ptr<workflow::WfStatement> functionBody);

		extern void												Workflow_CreatePointerVariable(Ptr<workflow::WfModule> module, GlobalStringKey name, description::ITypeDescriptor* type, description::ITypeInfo* typeOverride);
		extern void												Workflow_CreateVariablesForReferenceValues(Ptr<workflow::WfModule> module, types::ResolvingResult& resolvingResult);

		extern bool												Workflow_ValidateStatement(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, types::ErrorList& errors, const WString& code, Ptr<workflow::WfStatement> statement);
		extern Ptr<workflow::runtime::WfAssembly>				Workflow_PrecompileInstanceContext(Ptr<GuiInstanceContext> context, types::ErrorList& errors);
		extern Ptr<workflow::runtime::WfRuntimeGlobalContext>	Workflow_RunPrecompiledScript(Ptr<GuiResource> resource, Ptr<GuiResourceItem> resourceItem, description::Value rootInstance);
	}
}

#endif

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_TEMPLATECONTROL.H
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL
#define VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace controls;
			using namespace compositions;
			using namespace theme;
			using namespace helper_types;
		
			using namespace elements;
			using namespace compositions;
			using namespace controls;
			using namespace templates;

			using namespace workflow;
			using namespace workflow::analyzer;

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Helper Functions
***********************************************************************/

			template<typename TStruct>
			Value ParseConstantArgument(Ptr<WfExpression> value, const IGuiInstanceLoader::TypeInfo& typeInfo, const WString& propertyName, const WString& formatSample, collections::List<WString>& errors)
			{
				auto castExpr = value.Cast<WfTypeCastingExpression>();
				if (!castExpr)
				{
					errors.Add(L"Precompile: The value of property \"" + propertyName + L"\" of type \"" + typeInfo.typeName.ToString() + L"\" should be a constant.");
				}
				auto stringExpr = castExpr->expression.Cast<WfStringExpression>();
				if (!stringExpr)
				{
					errors.Add(L"Precompile: The value of property \"" + propertyName + L"\" of type \"" + typeInfo.typeName.ToString() + L"\" should be a constant.");
				}

				Value siteValue;
				if (!description::GetTypeDescriptor<TStruct>()->GetValueSerializer()->Parse(stringExpr->value.value, siteValue))
				{
					errors.Add(L"Precompile: \"" + stringExpr->value.value + L"\" is not in a right format." + (formatSample == L"" ? WString() : L" It should be \"" + formatSample + L"\", in which components are all optional."));
				}

				return siteValue;
			}

/***********************************************************************
GuiVrtualTypeInstanceLoader
***********************************************************************/

			template<typename TControl, typename TControlStyle, typename TTemplate>
			class GuiTemplateControlInstanceLoader : public Object, public IGuiInstanceLoader
			{
				typedef Ptr<WfExpression>				ArgumentRawFunctionType(ArgumentMap&);
				typedef void							InitRawFunctionType(const WString&, Ptr<WfBlockStatement>);
				typedef Func<ArgumentRawFunctionType>	ArgumentFunctionType;
				typedef Func<InitRawFunctionType>		InitFunctionType;

			protected:
				GlobalStringKey								typeName;
				WString										styleMethod;
				ArgumentFunctionType						argumentFunction;
				InitFunctionType							initFunction;

				virtual void PrepareAdditionalArguments(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfBlockStatement> block)
				{
				}

				virtual void AddAdditionalArguments(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfNewTypeExpression> createControl)
				{
				}

				virtual void PrepareAdditionalArgumentsAfterCreation(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfBlockStatement> block)
				{
				}
			public:

				static Ptr<WfExpression> CreateIThemeCall(const WString& method)
				{
					auto refPresentation = MakePtr<WfTopQualifiedExpression>();
					refPresentation->name.value = L"presentation";

					auto refTheme = MakePtr<WfChildExpression>();
					refTheme->parent = refPresentation;
					refTheme->name.value = L"theme";

					auto refITheme = MakePtr<WfChildExpression>();
					refITheme->parent = refTheme;
					refITheme->name.value = L"ITheme";

					auto refGetCurrentTheme = MakePtr<WfChildExpression>();
					refGetCurrentTheme->parent = refITheme;
					refGetCurrentTheme->name.value = L"GetCurrentTheme";

					auto call = MakePtr<WfCallExpression>();
					call->function = refGetCurrentTheme;

					auto refStyleMethod = MakePtr<WfMemberExpression>();
					refStyleMethod->parent = call;
					refStyleMethod->name.value = method;

					auto createStyle = MakePtr<WfCallExpression>();
					createStyle->function = refStyleMethod;
					return createStyle;
				}

				static Ptr<WfExpression> CreateStyleMethodArgument(const WString& method, ArgumentMap& arguments)
				{
					vint indexControlTemplate = arguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						auto refControlStyle = MakePtr<WfReferenceExpression>();
						refControlStyle->name.value = L"<controlStyle>";

						auto refCreateArgument = MakePtr<WfMemberExpression>();
						refCreateArgument->parent = refControlStyle;
						refCreateArgument->name.value = L"CreateArgument";

						auto call = MakePtr<WfCallExpression>();
						call->function = refCreateArgument;

						return call;
					}
					else
					{
						return CreateIThemeCall(method);
					}
				}

				static Ptr<WfExpression> CreateTemplateFactory(List<ITypeDescriptor*>& controlTemplateTds, collections::List<WString>& errors)
				{
					auto templateType = TypeInfoRetriver<TTemplate*>::CreateTypeInfo();
					auto factoryType = TypeInfoRetriver<Ptr<GuiTemplate::IFactory>>::CreateTypeInfo();

					auto refFactory = MakePtr<WfNewTypeExpression>();
					refFactory->type = GetTypeFromTypeInfo(factoryType.Obj());
					{
						auto funcCreateTemplate = MakePtr<WfFunctionDeclaration>();
						funcCreateTemplate->anonymity = WfFunctionAnonymity::Named;
						funcCreateTemplate->name.value = L"CreateTemplate";
						funcCreateTemplate->returnType = GetTypeFromTypeInfo(templateType.Obj());

						auto argViewModel = MakePtr<WfFunctionArgument>();
						argViewModel->type = GetTypeFromTypeInfo(TypeInfoRetriver<Value>::CreateTypeInfo().Obj());
						argViewModel->name.value = L"<viewModel>";
						funcCreateTemplate->arguments.Add(argViewModel);

						auto block = MakePtr<WfBlockStatement>();
						funcCreateTemplate->statement = block;
						
						ITypeDescriptor* stopControlTemplateTd = nullptr;
						FOREACH(ITypeDescriptor*, controlTemplateTd, controlTemplateTds)
						{
							if (stopControlTemplateTd)
							{
								errors.Add(L"Precompile: Type \"" + controlTemplateTd->GetTypeName() + L"\" will never be tried, because \"" + stopControlTemplateTd->GetTypeName() + L"\", which is listed before, has a default constructor. So whatever the view model is, it will be the last choice.");
								continue;
							}

							ITypeInfo* viewModelType = nullptr;
							{
								auto ctors = controlTemplateTd->GetConstructorGroup();
								if (ctors->GetMethodCount() != 1)
								{
									errors.Add(L"Precompile: To use type \"" + controlTemplateTd->GetTypeName() + L"\" as a control template or item template, it should have exactly one constructor.");
									continue;
								}

								auto ctor = ctors->GetMethod(0);
								if (ctor->GetParameterCount() > 1)
								{
									errors.Add(L"Precompile: To use type \"" + controlTemplateTd->GetTypeName() + L"\" as a control template or item template, its constructor cannot have more than one parameter.");
									continue;
								}

								if (ctor->GetParameterCount() != 0)
								{
									viewModelType = ctor->GetParameter(0)->GetType();
								}
							}

							if (!viewModelType)
							{
								stopControlTemplateTd = controlTemplateTd;
							}

							auto subBlock = MakePtr<WfBlockStatement>();
							block->statements.Add(subBlock);

							Ptr<ITypeInfo> controlTemplateType;
							{
								auto elementType = MakePtr<TypeInfoImpl>(ITypeInfo::TypeDescriptor);
								elementType->SetTypeDescriptor(controlTemplateTd);

								auto pointerType = MakePtr<TypeInfoImpl>(ITypeInfo::RawPtr);
								pointerType->SetElementType(elementType);

								controlTemplateType = pointerType;
							}

							Ptr<WfBlockStatement> returnStatBlock;
							if (viewModelType)
							{
								auto refViewModel = MakePtr<WfReferenceExpression>();
								refViewModel->name.value = L"<viewModel>";

								auto condition = MakePtr<WfTypeTestingExpression>();
								condition->test = WfTypeTesting::IsType;
								condition->expression = refViewModel;
								condition->type = GetTypeFromTypeInfo(viewModelType);

								auto ifStat = MakePtr<WfIfStatement>();
								ifStat->expression = condition;

								returnStatBlock = MakePtr<WfBlockStatement>();
								ifStat->trueBranch = returnStatBlock;
							}
							else
							{
								returnStatBlock = subBlock;
							}

							{
								auto createControlTemplate = MakePtr<WfNewTypeExpression>();
								createControlTemplate->type = GetTypeFromTypeInfo(controlTemplateType.Obj());
								if (viewModelType)
								{
									auto refViewModel = MakePtr<WfReferenceExpression>();
									refViewModel->name.value = L"<viewModel>";
									createControlTemplate->arguments.Add(refViewModel);
								}

								auto varTemplate = MakePtr<WfVariableDeclaration>();
								varTemplate->type = GetTypeFromTypeInfo(templateType.Obj());
								varTemplate->name.value = L"<template>";
								varTemplate->expression = createControlTemplate;

								auto varStat = MakePtr<WfVariableStatement>();
								varStat->variable = varTemplate;
								returnStatBlock->statements.Add(varStat);
							}
							{
								auto refTemplate = MakePtr<WfReferenceExpression>();
								refTemplate->name.value = L"<template>";

								auto returnStat = MakePtr<WfReturnStatement>();
								returnStat->expression = refTemplate;
								returnStatBlock->statements.Add(returnStat);
							}
						}

						if (!stopControlTemplateTd)
						{
						}

						refFactory->functions.Add(funcCreateTemplate);
					}

					return refFactory;
				}

				static Ptr<WfExpression> CreateTemplateFactory(ITypeDescriptor* controlTemplateTd, collections::List<WString>& errors)
				{
					List<ITypeDescriptor*> controlTemplateTds;
					controlTemplateTds.Add(controlTemplateTd);
					return CreateTemplateFactory(controlTemplateTds, errors);
				}

				static ITypeDescriptor* GetControlTemplateType(Ptr<WfExpression> argument, const TypeInfo& controlTypeInfo, collections::List<WString>& errors)
				{
					auto controlTemplateNameExpr = argument.Cast<WfStringExpression>();
					if (!controlTemplateNameExpr)
					{
						errors.Add(L"Precompile: The value of contructor parameter \"" + GlobalStringKey::_ControlTemplate.ToString() + L"\" of type \"" + controlTypeInfo.typeName.ToString() + L"\" should be a constant representing the control template type name.");
						return nullptr;
					}

					auto controlTemplateName = controlTemplateNameExpr->value.value;
					if (wcschr(controlTemplateName.Buffer(), L';') == nullptr)
					{
						errors.Add(L"Precompile: \"" + controlTemplateNameExpr->value.value + L"\", which is assigned to contructor parameter \"" + GlobalStringKey::_ControlTemplate.ToString() + L" of type \"" + controlTypeInfo.typeName.ToString() + L"\", is illegal because control template should not have multiple choices.");
						return nullptr;
					}

					auto controlTemplateTd = description::GetTypeDescriptor(controlTemplateName);
					if (!controlTemplateTd)
					{
						errors.Add(L"Precompile: Type \"" + controlTemplateNameExpr->value.value + L"\", which is assigned to contructor parameter \"" + GlobalStringKey::_ControlTemplate.ToString() + L" of type \"" + controlTypeInfo.typeName.ToString() + L"\", does not exist.");
						return nullptr;
					}

					return controlTemplateTd;
				}

				static void GetItemTemplateType(Ptr<WfExpression> argument, List<ITypeDescriptor*>& tds, const TypeInfo& controlTypeInfo, const WString& propertyName, collections::List<WString>& errors)
				{
					auto controlTemplateNameExpr = argument.Cast<WfStringExpression>();
					if (!controlTemplateNameExpr)
					{
						errors.Add(L"Precompile: The value of contructor parameter \"" + propertyName + L"\" of type \"" + controlTypeInfo.typeName.ToString() + L"\" should be a constant representing the control template type name.");
						return;
					}

					List<WString> typeNames;
					SplitBySemicolon(controlTemplateNameExpr->value.value, typeNames);

					FOREACH(WString, controlTemplateName, typeNames)
					{
						auto controlTemplateTd = description::GetTypeDescriptor(controlTemplateName);
						if (!controlTemplateTd)
						{
							errors.Add(L"Precompile: Type \"" + controlTemplateNameExpr->value.value + L"\", which is assigned to contructor parameter \"" + propertyName + L" of type \"" + controlTypeInfo.typeName.ToString() + L"\", does not exist.");
							continue;
						}
						tds.Add(controlTemplateTd);
					}
				}

			public:
				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
				{
				}

				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod, WString argumentStyleMethod)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
					, argumentFunction([argumentStyleMethod](ArgumentMap& arguments){return CreateStyleMethodArgument(argumentStyleMethod, arguments);})
				{
				}

				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod, ArgumentRawFunctionType* _argumentFunction)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
					, argumentFunction(_argumentFunction)
				{
				}

				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod, InitRawFunctionType* _initFunction)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
					, initFunction(_initFunction)
				{
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::_ControlTemplate);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						return info;
					}
					return 0;
				}

				bool CanCreate(const TypeInfo& typeInfo)override
				{
					return typeName == typeInfo.typeName;
				}

				Ptr<workflow::WfStatement> CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					CHECK_ERROR(typeName == typeInfo.typeName, L"GuiTemplateControlInstanceLoader::CreateInstance# Wrong type info is provided.");
					vint indexControlTemplate = arguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);

					Ptr<WfExpression> createStyleExpr;
					if (indexControlTemplate == -1)
					{
						createStyleExpr = CreateIThemeCall(styleMethod);
					}
					else
					{
						if (auto controlTemplateTd = GetControlTemplateType(arguments.GetByIndex(indexControlTemplate)[0].expression, typeInfo, errors))
						{
							auto styleType = TypeInfoRetriver<TControlStyle*>::CreateTypeInfo();

							auto refFactory = CreateTemplateFactory(controlTemplateTd, errors);
							auto createStyle = MakePtr<WfNewTypeExpression>();
							createStyle->type = GetTypeFromTypeInfo(styleType.Obj());
							createStyle->arguments.Add(refFactory);
							createStyleExpr = createStyle;
						}
						else
						{
							return nullptr;
						}
					}
				
					auto block = MakePtr<WfBlockStatement>();
					{
						auto varTemplate = MakePtr<WfVariableDeclaration>();
						varTemplate->name.value = L"<controlStyle>";
						varTemplate->expression = createStyleExpr;

						auto varStat = MakePtr<WfVariableStatement>();
						varStat->variable = varTemplate;
						block->statements.Add(varStat);
					}
					PrepareAdditionalArguments(typeInfo, variableName, arguments, errors, block);
					{
						auto controlType = TypeInfoRetriver<TControl*>::CreateTypeInfo();

						auto createControl = MakePtr<WfNewTypeExpression>();
						createControl->type = GetTypeFromTypeInfo(controlType.Obj());
						{
							auto refControlStyle = MakePtr<WfReferenceExpression>();
							refControlStyle->name.value = L"<controlStyle>";

							createControl->arguments.Add(refControlStyle);
						}

						if (argumentFunction)
						{
							createControl->arguments.Add(argumentFunction(arguments));
						}
						AddAdditionalArguments(typeInfo, variableName, arguments, errors, createControl);

						auto refVariable = MakePtr<WfReferenceExpression>();
						refVariable->name.value = variableName.ToString();

						auto assignExpr = MakePtr<WfBinaryExpression>();
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refVariable;
						assignExpr->second = createControl;

						auto assignStat = MakePtr<WfExpressionStatement>();
						assignStat->expression = assignExpr;
						block->statements.Add(assignStat);
					}

					PrepareAdditionalArgumentsAfterCreation(typeInfo, variableName, arguments, errors, block);
					if (initFunction)
					{
						initFunction(variableName.ToString(), block);
					}
					return block;
				}
			};
#endif
		}
	}
}
#endif
