/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "Vlpp.h"
#include "VlppWorkflow.h"
#include "VlppWorkflowCompiler.h"
#include "GacUI.h"
#include "GacUIReflection.h"

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::GuiInstanceQuery_Parser

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER


namespace vl
{
	namespace presentation
	{
		enum class GuiIqParserTokenIndex
		{
			INDIRECT = 0,
			DIRECT = 1,
			NAME = 2,
			WILDCARD = 3,
			OPEN = 4,
			CLOSE = 5,
			XOR = 6,
			INTERSECT = 7,
			UNION = 8,
			SUBSTRACT = 9,
			ATTRIBUTE = 10,
			COLON = 11,
			DOT = 12,
			SPACE = 13,
		};
		class GuiIqQuery;
		class GuiIqPrimaryQuery;
		class GuiIqCascadeQuery;
		class GuiIqSetQuery;

		class GuiIqQuery abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<GuiIqQuery>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(GuiIqPrimaryQuery* node)=0;
				virtual void Visit(GuiIqCascadeQuery* node)=0;
				virtual void Visit(GuiIqSetQuery* node)=0;
			};

			virtual void Accept(GuiIqQuery::IVisitor* visitor)=0;

		};

		enum class GuiIqNameOption
		{
			Specified,
			Any,
		};

		enum class GuiIqChildOption
		{
			Direct,
			Indirect,
		};

		class GuiIqPrimaryQuery : public GuiIqQuery, vl::reflection::Description<GuiIqPrimaryQuery>
		{
		public:
			GuiIqChildOption childOption;
			GuiIqNameOption attributeNameOption;
			vl::parsing::ParsingToken attributeName;
			GuiIqNameOption typeNameOption;
			vl::parsing::ParsingToken typeName;
			vl::parsing::ParsingToken referenceName;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqPrimaryQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class GuiIqCascadeQuery : public GuiIqQuery, vl::reflection::Description<GuiIqCascadeQuery>
		{
		public:
			vl::Ptr<GuiIqQuery> parent;
			vl::Ptr<GuiIqQuery> child;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqCascadeQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class GuiIqBinaryOperator
		{
			ExclusiveOr,
			Intersect,
			Union,
			Substract,
		};

		class GuiIqSetQuery : public GuiIqQuery, vl::reflection::Description<GuiIqSetQuery>
		{
		public:
			vl::Ptr<GuiIqQuery> first;
			vl::Ptr<GuiIqQuery> second;
			GuiIqBinaryOperator op;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqSetQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		extern vl::WString GuiIqGetParserTextBuffer();
		extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> GuiIqConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		extern vl::Ptr<vl::parsing::tabling::ParsingTable> GuiIqLoadTable();

		extern vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::presentation::GuiIqQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqNameOption)
			DECL_TYPE_INFO(vl::presentation::GuiIqChildOption)
			DECL_TYPE_INFO(vl::presentation::GuiIqPrimaryQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqCascadeQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqBinaryOperator)
			DECL_TYPE_INFO(vl::presentation::GuiIqSetQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqQuery::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::presentation::GuiIqQuery::IVisitor)
				void Visit(vl::presentation::GuiIqPrimaryQuery* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::presentation::GuiIqCascadeQuery* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::presentation::GuiIqSetQuery* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::presentation::GuiIqQuery::IVisitor)

#endif
			extern bool GuiIqLoadTypes();
		}
	}
}
#endif

/***********************************************************************
GUIINSTANCEREPRESENTATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Instance Representation
***********************************************************************/

		class GuiTextRepr;
		class GuiAttSetterRepr;
		class GuiConstructorRepr;
		class IGuiInstanceCache;

		class GuiValueRepr : public Object, public Description<GuiValueRepr>
		{
		public:
			class IVisitor : public IDescriptable, public Description<IVisitor>
			{
			public:
				virtual void						Visit(GuiTextRepr* repr)=0;
				virtual void						Visit(GuiAttSetterRepr* repr)=0;
				virtual void						Visit(GuiConstructorRepr* repr)=0;
			};

			bool									fromStyle = false;

			virtual void							Accept(IVisitor* visitor) = 0;
			virtual Ptr<GuiValueRepr>				Clone() = 0;
			virtual void							FillXml(Ptr<parsing::xml::XmlElement> xml) = 0;
		};

		class GuiTextRepr : public GuiValueRepr, public Description<GuiTextRepr>
		{
		public:
			static const vint						BinaryKey = 1;

			WString									text;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

		class GuiAttSetterRepr : public GuiValueRepr, public Description<GuiAttSetterRepr>
		{
		public:
			typedef collections::List<Ptr<GuiValueRepr>>						ValueList;
			static const vint						BinaryKey = 2;

			struct SetterValue : public Object, public Description<SetterValue>
			{
				GlobalStringKey						binding;
				ValueList							values;
			};

			struct EventValue : public Object, public Description<EventValue>
			{
				GlobalStringKey						binding;
				WString								value;
				bool								fromStyle = false;
			};
			
			typedef collections::Dictionary<GlobalStringKey, Ptr<SetterValue>>			SetteValuerMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<EventValue>>			EventHandlerMap;
		public:
			SetteValuerMap							setters;					// empty key means default property
			EventHandlerMap							eventHandlers;
			GlobalStringKey							instanceName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			void									CloneBody(Ptr<GuiAttSetterRepr> repr);
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

		class GuiConstructorRepr : public GuiAttSetterRepr, public Description<GuiConstructorRepr>
		{
		public:
			static const vint						BinaryKey = 3;

			GlobalStringKey							typeNamespace;
			GlobalStringKey							typeName;
			Nullable<WString>						styleName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

/***********************************************************************
Instance Namespace
***********************************************************************/

		class GuiInstanceNamespace : public Object, public Description<GuiInstanceNamespace>
		{
		public:
			WString									prefix;
			WString									postfix;
		};

		// Workflow:	<name>
		// C++:			<instance>->Get<name>
		class GuiInstanceParameter : public Object, public Description<GuiInstanceParameter>
		{
		public:
			GlobalStringKey							name;
			GlobalStringKey							className;
		};

		// Workflow:	<instance>.<name>
		// C++:			<instance>->Get<name>
		//				<instance>->Set<name>
		class GuiInstanceProperty : public Object, public Description<GuiInstanceProperty>
		{
		public:
			GlobalStringKey							name;
			WString									typeName;
			bool									readonly = false;
		};
		
		// Workflow:	<instance>.<name>
		// C++:			<instance>-><name>
		class GuiInstanceState : public Object, public Description<GuiInstanceState>
		{
		public:
			GlobalStringKey							name;
			WString									typeName;
			WString									value;
		};

/***********************************************************************
Instance Context
***********************************************************************/

		class GuiInstanceStyleContext;

		class GuiInstanceContext : public Object, public Description<GuiInstanceContext>
		{
		public:
			typedef collections::List<Ptr<GuiInstanceNamespace>>						NamespaceList;

			struct NamespaceInfo : public Object, public Description<NamespaceInfo>
			{
				GlobalStringKey						name;
				NamespaceList						namespaces;
			};
			typedef collections::Dictionary<GlobalStringKey, Ptr<NamespaceInfo>>		NamespaceMap;
			typedef collections::List<Ptr<GuiInstanceParameter>>						ParameterList;
			typedef collections::List<Ptr<GuiInstanceProperty>>							PropertyList;
			typedef collections::List<Ptr<GuiInstanceState>>							StateList;
			typedef collections::List<Ptr<GuiInstanceStyleContext>>						StyleContextList;

			class ElementName : public Object
			{
			public:
				WString								namespaceName;				// empty key means default namespace
				WString								category;
				WString								name;
				WString								binding;

				bool IsCtorName(){ return category==L"" && name!=L"" && binding==L""; }
				bool IsReferenceAttributeName(){ return namespaceName==L"" && category==L"ref" && name!=L"" && binding==L""; }
				bool IsPropertyAttributeName(){ return namespaceName==L"" && category==L"" && name!=L""; }
				bool IsPropertyElementName(){ return namespaceName==L"" && category==L"att" && name!=L""; }
				bool IsEventAttributeName(){ return namespaceName==L"" && category==L"ev" && name!=L""; }
				bool IsEventElementName(){ return namespaceName==L"" && category==L"ev" && name!=L""; }
			};
		public:
			Ptr<GuiConstructorRepr>					instance;
			NamespaceMap							namespaces;
			bool									codeBehind = true;
			WString									className;
			ParameterList							parameters;
			PropertyList							properties;
			StateList								states;
			collections::List<WString>				stylePaths;

			bool									appliedStyles = false;
			StyleContextList						styles;

			static void								CollectDefaultAttributes(GuiAttSetterRepr::ValueList& values, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static void								CollectAttributes(GuiAttSetterRepr::SetteValuerMap& setters, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static void								CollectEvents(GuiAttSetterRepr::EventHandlerMap& eventHandlers, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static void								FillAttSetter(Ptr<GuiAttSetterRepr> setter, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static Ptr<GuiConstructorRepr>			LoadCtor(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			static Ptr<GuiInstanceContext>			LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
			bool									ApplyStyles(Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors);
		};

/***********************************************************************
Instance Style Context
***********************************************************************/

		class GuiInstanceStyle : public Object, public Description<GuiInstanceStyle>
		{
		public:
			Ptr<GuiIqQuery>							query;
			Ptr<GuiAttSetterRepr>					setter;

			static Ptr<GuiInstanceStyle>			LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlElement>			SaveToXml();
		};

		class GuiInstanceStyleContext : public Object, public Description<GuiInstanceStyleContext>
		{
			typedef collections::List<Ptr<GuiInstanceStyle>>		StyleList;
		public:
			StyleList								styles;

			static Ptr<GuiInstanceStyleContext>		LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
		};
	}
}

#endif

/***********************************************************************
GUIINSTANCELOADER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOADER
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOADER


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

/***********************************************************************
Instance Loader
***********************************************************************/

		class GuiInstancePropertyInfo : public IDescriptable, public Description<GuiInstancePropertyInfo>
		{
			typedef collections::List<description::ITypeDescriptor*>		TypeDescriptorList;
		public:
			enum Support
			{
				NotSupport,
				SupportAssign,
				SupportArray,
				SupportCollection,
				SupportSet,
			};

			enum PropertyScope
			{
				ViewModel,		// <ref.Parameter/>
				Constructor,	// constructor parameter that is not ViewModel
				Property,		// property of the class
			};

			Support									support = NotSupport;
			bool									tryParent = false;
			bool									required = false;			// only apply to constructor
			bool									bindable = false;			// only apply to constructor
			PropertyScope							scope = Property;
			TypeDescriptorList						acceptableTypes;

			static Ptr<GuiInstancePropertyInfo>		Unsupported();
			static Ptr<GuiInstancePropertyInfo>		Assign(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		AssignWithParent(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		Collection(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		CollectionWithParent(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		Set(description::ITypeDescriptor* typeDescriptor = 0);
			static Ptr<GuiInstancePropertyInfo>		Array(description::ITypeDescriptor* typeDescriptor = 0);
		};

		class IGuiInstanceLoader : public IDescriptable, public Description<IGuiInstanceLoader>
		{
		public:
			struct TypeInfo
			{
				GlobalStringKey						typeName;
				description::ITypeDescriptor*		typeDescriptor;

				TypeInfo() :typeDescriptor(0){}
				TypeInfo(GlobalStringKey _typeName, description::ITypeDescriptor* _typeDescriptor)
					:typeName(_typeName)
					, typeDescriptor(_typeDescriptor)
				{
				}
			};

			struct PropertyInfo
			{
				TypeInfo							typeInfo;
				GlobalStringKey						propertyName;

				PropertyInfo(){}
				PropertyInfo(const TypeInfo& _typeInfo, GlobalStringKey _propertyName)
					:typeInfo(_typeInfo)
					, propertyName(_propertyName)
				{
				}
			};

			struct PropertyValue : PropertyInfo
			{
				description::Value					instanceValue;
				description::Value					propertyValue;

				PropertyValue(){}
				PropertyValue(const TypeInfo& _typeInfo, GlobalStringKey _propertyName, description::Value _instanceValue, description::Value _propertyValue = description::Value())
					:PropertyInfo(_typeInfo, _propertyName)
					, instanceValue(_instanceValue)
					, propertyValue(_propertyValue)
				{
				}
			};

			struct ArgumentInfo
			{
				Ptr<workflow::WfExpression>			expression;
				description::ITypeDescriptor*		type;
			};

			typedef collections::Group<GlobalStringKey, ArgumentInfo>	ArgumentMap;

			virtual GlobalStringKey					GetTypeName() = 0;

			virtual void							GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void							GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void							GetPairedProperties(const PropertyInfo& propertyInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual Ptr<GuiInstancePropertyInfo>	GetPropertyType(const PropertyInfo& propertyInfo);

			virtual bool							CanCreate(const TypeInfo& typeInfo);
			virtual Ptr<workflow::WfStatement>		CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors);
			virtual Ptr<workflow::WfStatement>		AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors);
			virtual Ptr<workflow::WfExpression>		GetParameter(const PropertyInfo& propertyInfo, GlobalStringKey variableName, collections::List<WString>& errors);
		};

/***********************************************************************
Instance Binder
***********************************************************************/

		class IGuiInstanceBinder : public IDescriptable, public Description<IGuiInstanceBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual bool							ApplicableToConstructorArgument() = 0;
			virtual bool							RequirePropertyExist() = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors) = 0;
		};

		class IGuiInstanceEventBinder : public IDescriptable, public Description<IGuiInstanceEventBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& code, collections::List<WString>& errors) = 0;
		};

/***********************************************************************
Instance Loader Manager
***********************************************************************/

		class IGuiInstanceLoaderManager : public IDescriptable, public Description<IGuiInstanceLoaderManager>
		{
		public:
			virtual bool								AddInstanceBinder(Ptr<IGuiInstanceBinder> binder) = 0;
			virtual IGuiInstanceBinder*					GetInstanceBinder(GlobalStringKey bindingName) = 0;
			virtual bool								AddInstanceEventBinder(Ptr<IGuiInstanceEventBinder> binder) = 0;
			virtual IGuiInstanceEventBinder*			GetInstanceEventBinder(GlobalStringKey bindingName) = 0;
			virtual bool								CreateVirtualType(GlobalStringKey parentType, Ptr<IGuiInstanceLoader> loader) = 0;
			virtual bool								SetLoader(Ptr<IGuiInstanceLoader> loader) = 0;
			virtual IGuiInstanceLoader*					GetLoader(GlobalStringKey typeName) = 0;
			virtual IGuiInstanceLoader*					GetParentLoader(IGuiInstanceLoader* loader) = 0;
			virtual description::ITypeDescriptor*		GetTypeDescriptorForType(GlobalStringKey typeName) = 0;
			virtual void								GetVirtualTypes(collections::List<GlobalStringKey>& typeNames) = 0;
			virtual GlobalStringKey						GetParentTypeForVirtualType(GlobalStringKey virtualType) = 0;
		};

		struct InstanceLoadingSource
		{
			IGuiInstanceLoader*						loader;
			GlobalStringKey							typeName;
			Ptr<GuiResourceItem>					item;
			Ptr<GuiInstanceContext>					context;

			InstanceLoadingSource()
				:loader(0)
			{
			}

			InstanceLoadingSource(IGuiInstanceLoader* _loader, GlobalStringKey _typeName)
				:loader(_loader)
				, typeName(_typeName)
			{
			}

			InstanceLoadingSource(Ptr<GuiResourceItem> _item)
				:loader(0)
				, item(_item)
				, context(item->GetContent().Cast<GuiInstanceContext>())
			{
			}

			operator bool()const
			{
				return loader != 0 || context;
			}
		};

		extern IGuiInstanceLoaderManager*			GetInstanceLoaderManager();
		extern InstanceLoadingSource				FindInstanceLoadingSource(Ptr<GuiInstanceContext> context, GuiConstructorRepr* ctor);
	}
}

#endif

/***********************************************************************
GUIINSTANCEHELPERTYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Helper Types

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEHELPERTYPES
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEHELPERTYPES


#if defined(__APPLE__) || defined(__APPLE_CC__)

using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::templates;
using namespace vl::presentation::theme;

#endif

namespace vl
{
	namespace presentation
	{

/***********************************************************************
Helper Types
***********************************************************************/

		namespace helper_types
		{
			struct SiteValue
			{
				vint			row;
				vint			column;
				vint			rowSpan;
				vint			columnSpan;

				SiteValue() :row(0), column(0), rowSpan(1), columnSpan(1){}
			};

			enum class ListViewViewType
			{
				BigIcon,
				SmallIcon,
				List,
				Tile,
				Information,
				Detail,
			};
		}
	}

#ifndef VCZH_DEBUG_NO_REFLECTION

	namespace reflection
	{
		namespace description
		{

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONHELPERTYPES_TYPELIST(F)\
			F(presentation::helper_types::SiteValue)\
			F(presentation::helper_types::ListViewViewType)\

			GUIREFLECTIONHELPERTYPES_TYPELIST(DECL_TYPE_INFO)
		}
	}

#endif
}

#endif

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Query

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY


namespace vl
{
	namespace presentation
	{
		extern void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& input, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ApplyStyle(Ptr<GuiInstanceStyle> style, Ptr<GuiConstructorRepr> ctor);
		extern void GuiIqPrint(Ptr<GuiIqQuery> query, stream::StreamWriter& writer);
	}
}

#endif

/***********************************************************************
GUIINSTANCESHAREDSCRIPT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT


namespace vl
{
	namespace presentation
	{
		class GuiInstanceSharedScript :public Object, public Description<GuiInstanceSharedScript>
		{
		public:
			WString										language;
			WString										code;

			static Ptr<GuiInstanceSharedScript>			LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors);
			Ptr<parsing::xml::XmlElement>				SaveToXml();
		};
	}
}

#endif

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWCODEGEN.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Schema Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN


namespace vl
{
	namespace presentation
	{
		namespace types
		{
			struct PropertyResolving
			{
				IGuiInstanceLoader*								loader = nullptr;
				IGuiInstanceLoader::PropertyInfo				propertyInfo;
				Ptr<GuiInstancePropertyInfo>					info;
			};

			typedef collections::Dictionary<GlobalStringKey, IGuiInstanceLoader::TypeInfo>		VariableTypeInfoMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<description::ITypeInfo>>		TypeOverrideMap;
			typedef collections::Dictionary<GuiValueRepr*, PropertyResolving>					PropertyResolvingMap;
			typedef collections::List<WString>													ErrorList;

			struct ResolvingResult
			{
				VariableTypeInfoMap								typeInfos;
				TypeOverrideMap									typeOverrides;
				PropertyResolvingMap							propertyResolvings;
			};
		}
		extern workflow::analyzer::WfLexicalScopeManager*		Workflow_GetSharedManager();
		

/***********************************************************************
WorkflowCompiler (Parser)
***********************************************************************/
		
		extern Ptr<workflow::WfExpression>						Workflow_ParseExpression(const WString& code, types::ErrorList& errors);
		extern Ptr<workflow::WfStatement>						Workflow_ParseStatement(const WString& code, types::ErrorList& errors);
		extern WString											Workflow_ModuleToString(Ptr<workflow::WfModule> module);

/***********************************************************************
WorkflowCompiler (Installation)
***********************************************************************/

		extern Ptr<workflow::WfStatement>						Workflow_InstallUriProperty(GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& protocol, const WString& path, collections::List<WString>& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallBindProperty(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, Ptr<workflow::WfExpression> bindExpression);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalProperty(GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, Ptr<workflow::WfExpression> evalExpression, collections::List<WString>& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvent(GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& handlerName);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalEvent(GlobalStringKey variableName, description::IEventInfo* eventInfo, Ptr<workflow::WfStatement> evalStatement);

/***********************************************************************
WorkflowCompiler (Compile)
***********************************************************************/

		extern Ptr<workflow::WfModule>							Workflow_CreateEmptyModule(Ptr<GuiInstanceContext> context);
		extern Ptr<workflow::WfModule>							Workflow_CreateModuleWithInitFunction(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, Ptr<workflow::WfStatement> functionBody);

		extern void												Workflow_CreatePointerVariable(Ptr<workflow::WfModule> module, GlobalStringKey name, description::ITypeDescriptor* type, description::ITypeInfo* typeOverride);
		extern void												Workflow_CreateVariablesForReferenceValues(Ptr<workflow::WfModule> module, types::ResolvingResult& resolvingResult);

		extern bool												Workflow_ValidateStatement(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, types::ErrorList& errors, const WString& code, Ptr<workflow::WfStatement> statement);
		extern Ptr<workflow::runtime::WfAssembly>				Workflow_PrecompileInstanceContext(Ptr<GuiInstanceContext> context, types::ErrorList& errors);
	}
}

#endif

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_TEMPLATECONTROL.H
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL
#define VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace controls;
			using namespace compositions;
			using namespace theme;
			using namespace helper_types;
		
			using namespace elements;
			using namespace compositions;
			using namespace controls;
			using namespace templates;

			using namespace workflow;
			using namespace workflow::analyzer;

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
Helper Functions
***********************************************************************/

			template<typename TStruct>
			Value ParseConstantArgument(Ptr<WfExpression> value, const IGuiInstanceLoader::TypeInfo& typeInfo, const WString& propertyName, const WString& formatSample, collections::List<WString>& errors)
			{
				auto castExpr = value.Cast<WfTypeCastingExpression>();
				if (!castExpr)
				{
					errors.Add(L"Precompile: The value of property \"" + propertyName + L"\" of type \"" + typeInfo.typeName.ToString() + L"\" should be a constant.");
				}
				auto stringExpr = castExpr->expression.Cast<WfStringExpression>();
				if (!stringExpr)
				{
					errors.Add(L"Precompile: The value of property \"" + propertyName + L"\" of type \"" + typeInfo.typeName.ToString() + L"\" should be a constant.");
				}

				Value siteValue;
				if (!description::GetTypeDescriptor<TStruct>()->GetValueSerializer()->Parse(stringExpr->value.value, siteValue))
				{
					errors.Add(L"Precompile: \"" + stringExpr->value.value + L"\" is not in a right format." + (formatSample == L"" ? WString() : L" It should be \"" + formatSample + L"\", in which components are all optional."));
				}

				return siteValue;
			}

/***********************************************************************
GuiVrtualTypeInstanceLoader
***********************************************************************/

			template<typename TControl, typename TControlStyle, typename TTemplate>
			class GuiTemplateControlInstanceLoader : public Object, public IGuiInstanceLoader
			{
				typedef Ptr<WfExpression>				ArgumentRawFunctionType(ArgumentMap&);
				typedef void							InitRawFunctionType(const WString&, Ptr<WfBlockStatement>);
				typedef Func<ArgumentRawFunctionType>	ArgumentFunctionType;
				typedef Func<InitRawFunctionType>		InitFunctionType;

			protected:
				GlobalStringKey								typeName;
				WString										styleMethod;
				ArgumentFunctionType						argumentFunction;
				InitFunctionType							initFunction;

				virtual void PrepareAdditionalArguments(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfBlockStatement> block)
				{
				}

				virtual void AddAdditionalArguments(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfNewClassExpression> createControl)
				{
				}

				virtual void PrepareAdditionalArgumentsAfterCreation(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfBlockStatement> block)
				{
				}
			public:

				static Ptr<WfExpression> CreateIThemeCall(const WString& method)
				{
					auto refPresentation = MakePtr<WfTopQualifiedExpression>();
					refPresentation->name.value = L"presentation";

					auto refTheme = MakePtr<WfChildExpression>();
					refTheme->parent = refPresentation;
					refTheme->name.value = L"theme";

					auto refITheme = MakePtr<WfChildExpression>();
					refITheme->parent = refTheme;
					refITheme->name.value = L"ITheme";

					auto refGetCurrentTheme = MakePtr<WfChildExpression>();
					refGetCurrentTheme->parent = refITheme;
					refGetCurrentTheme->name.value = L"GetCurrentTheme";

					auto call = MakePtr<WfCallExpression>();
					call->function = refGetCurrentTheme;

					auto refStyleMethod = MakePtr<WfMemberExpression>();
					refStyleMethod->parent = call;
					refStyleMethod->name.value = method;

					auto createStyle = MakePtr<WfCallExpression>();
					createStyle->function = refStyleMethod;
					return createStyle;
				}

				static Ptr<WfExpression> CreateStyleMethodArgument(const WString& method, ArgumentMap& arguments)
				{
					vint indexControlTemplate = arguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						auto refControlStyle = MakePtr<WfReferenceExpression>();
						refControlStyle->name.value = L"<controlStyle>";

						auto refCreateArgument = MakePtr<WfMemberExpression>();
						refCreateArgument->parent = refControlStyle;
						refCreateArgument->name.value = L"CreateArgument";

						auto call = MakePtr<WfCallExpression>();
						call->function = refCreateArgument;

						return call;
					}
					else
					{
						return CreateIThemeCall(method);
					}
				}

				static Ptr<WfExpression> CreateTemplateFactory(List<ITypeDescriptor*>& controlTemplateTds, collections::List<WString>& errors)
				{
					auto templateType = TypeInfoRetriver<TTemplate*>::CreateTypeInfo();
					auto factoryType = TypeInfoRetriver<Ptr<GuiTemplate::IFactory>>::CreateTypeInfo();

					auto refFactory = MakePtr<WfNewInterfaceExpression>();
					refFactory->type = GetTypeFromTypeInfo(factoryType.Obj());
					{
						auto funcCreateTemplate = MakePtr<WfFunctionDeclaration>();
						funcCreateTemplate->anonymity = WfFunctionAnonymity::Named;
						funcCreateTemplate->name.value = L"CreateTemplate";
						funcCreateTemplate->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<GuiTemplate*>::CreateTypeInfo().Obj());

						auto argViewModel = MakePtr<WfFunctionArgument>();
						argViewModel->type = GetTypeFromTypeInfo(TypeInfoRetriver<Value>::CreateTypeInfo().Obj());
						argViewModel->name.value = L"<viewModel>";
						funcCreateTemplate->arguments.Add(argViewModel);

						auto block = MakePtr<WfBlockStatement>();
						funcCreateTemplate->statement = block;
						
						ITypeDescriptor* stopControlTemplateTd = nullptr;
						FOREACH(ITypeDescriptor*, controlTemplateTd, controlTemplateTds)
						{
							if (stopControlTemplateTd)
							{
								errors.Add(L"Precompile: Type \"" + controlTemplateTd->GetTypeName() + L"\" will never be tried, because \"" + stopControlTemplateTd->GetTypeName() + L"\", which is listed before, has a default constructor. So whatever the view model is, it will be the last choice.");
								continue;
							}

							ITypeInfo* viewModelType = nullptr;
							{
								auto ctors = controlTemplateTd->GetConstructorGroup();
								if (ctors->GetMethodCount() != 1)
								{
									errors.Add(L"Precompile: To use type \"" + controlTemplateTd->GetTypeName() + L"\" as a control template or item template, it should have exactly one constructor.");
									continue;
								}

								auto ctor = ctors->GetMethod(0);
								if (ctor->GetParameterCount() > 1)
								{
									errors.Add(L"Precompile: To use type \"" + controlTemplateTd->GetTypeName() + L"\" as a control template or item template, its constructor cannot have more than one parameter.");
									continue;
								}

								if (ctor->GetParameterCount() != 0)
								{
									viewModelType = ctor->GetParameter(0)->GetType();
								}
							}

							if (!viewModelType)
							{
								stopControlTemplateTd = controlTemplateTd;
							}

							auto subBlock = MakePtr<WfBlockStatement>();
							block->statements.Add(subBlock);

							Ptr<ITypeInfo> controlTemplateType;
							{
								auto elementType = MakePtr<TypeInfoImpl>(ITypeInfo::TypeDescriptor);
								elementType->SetTypeDescriptor(controlTemplateTd);

								auto pointerType = MakePtr<TypeInfoImpl>(ITypeInfo::RawPtr);
								pointerType->SetElementType(elementType);

								controlTemplateType = pointerType;
							}

							Ptr<WfBlockStatement> returnStatBlock;
							if (viewModelType)
							{
								auto refViewModel = MakePtr<WfReferenceExpression>();
								refViewModel->name.value = L"<viewModel>";

								auto condition = MakePtr<WfTypeTestingExpression>();
								condition->test = WfTypeTesting::IsType;
								condition->expression = refViewModel;
								condition->type = GetTypeFromTypeInfo(viewModelType);

								auto ifStat = MakePtr<WfIfStatement>();
								ifStat->expression = condition;

								returnStatBlock = MakePtr<WfBlockStatement>();
								ifStat->trueBranch = returnStatBlock;
							}
							else
							{
								returnStatBlock = subBlock;
							}

							{
								auto createControlTemplate = MakePtr<WfNewClassExpression>();
								createControlTemplate->type = GetTypeFromTypeInfo(controlTemplateType.Obj());
								if (viewModelType)
								{
									auto refViewModel = MakePtr<WfReferenceExpression>();
									refViewModel->name.value = L"<viewModel>";
									createControlTemplate->arguments.Add(refViewModel);
								}

								auto varTemplate = MakePtr<WfVariableDeclaration>();
								varTemplate->type = GetTypeFromTypeInfo(templateType.Obj());
								varTemplate->name.value = L"<template>";
								varTemplate->expression = createControlTemplate;

								auto varStat = MakePtr<WfVariableStatement>();
								varStat->variable = varTemplate;
								returnStatBlock->statements.Add(varStat);
							}
							{
								auto refTemplate = MakePtr<WfReferenceExpression>();
								refTemplate->name.value = L"<template>";

								auto returnStat = MakePtr<WfReturnStatement>();
								returnStat->expression = refTemplate;
								returnStatBlock->statements.Add(returnStat);
							}
						}

						auto member = MakePtr<WfClassMember>();
						member->kind = WfClassMemberKind::Override;
						member->declaration = funcCreateTemplate;

						refFactory->members.Add(member);
					}

					return refFactory;
				}

				static Ptr<WfExpression> CreateTemplateFactory(ITypeDescriptor* controlTemplateTd, collections::List<WString>& errors)
				{
					List<ITypeDescriptor*> controlTemplateTds;
					controlTemplateTds.Add(controlTemplateTd);
					return CreateTemplateFactory(controlTemplateTds, errors);
				}

				static ITypeDescriptor* GetControlTemplateType(Ptr<WfExpression> argument, const TypeInfo& controlTypeInfo, collections::List<WString>& errors)
				{
					auto controlTemplateNameExpr = argument.Cast<WfStringExpression>();
					if (!controlTemplateNameExpr)
					{
						errors.Add(L"Precompile: The value of contructor parameter \"" + GlobalStringKey::_ControlTemplate.ToString() + L"\" of type \"" + controlTypeInfo.typeName.ToString() + L"\" should be a constant representing the control template type name.");
						return nullptr;
					}

					auto controlTemplateName = controlTemplateNameExpr->value.value;
					if (wcschr(controlTemplateName.Buffer(), L';') != nullptr)
					{
						errors.Add(L"Precompile: \"" + controlTemplateNameExpr->value.value + L"\", which is assigned to contructor parameter \"" + GlobalStringKey::_ControlTemplate.ToString() + L" of type \"" + controlTypeInfo.typeName.ToString() + L"\", is illegal because control template should not have multiple choices.");
						return nullptr;
					}

					auto controlTemplateTd = description::GetTypeDescriptor(controlTemplateName);
					if (!controlTemplateTd)
					{
						errors.Add(L"Precompile: Type \"" + controlTemplateNameExpr->value.value + L"\", which is assigned to contructor parameter \"" + GlobalStringKey::_ControlTemplate.ToString() + L" of type \"" + controlTypeInfo.typeName.ToString() + L"\", does not exist.");
						return nullptr;
					}

					return controlTemplateTd;
				}

				static void GetItemTemplateType(Ptr<WfExpression> argument, List<ITypeDescriptor*>& tds, const TypeInfo& controlTypeInfo, const WString& propertyName, collections::List<WString>& errors)
				{
					auto controlTemplateNameExpr = argument.Cast<WfStringExpression>();
					if (!controlTemplateNameExpr)
					{
						errors.Add(L"Precompile: The value of contructor parameter \"" + propertyName + L"\" of type \"" + controlTypeInfo.typeName.ToString() + L"\" should be a constant representing the control template type name.");
						return;
					}

					List<WString> typeNames;
					SplitBySemicolon(controlTemplateNameExpr->value.value, typeNames);

					FOREACH(WString, controlTemplateName, typeNames)
					{
						auto controlTemplateTd = description::GetTypeDescriptor(controlTemplateName);
						if (!controlTemplateTd)
						{
							errors.Add(L"Precompile: Type \"" + controlTemplateNameExpr->value.value + L"\", which is assigned to contructor parameter \"" + propertyName + L" of type \"" + controlTypeInfo.typeName.ToString() + L"\", does not exist.");
							continue;
						}
						tds.Add(controlTemplateTd);
					}
				}

			public:
				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
				{
				}

				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod, WString argumentStyleMethod)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
					, argumentFunction([argumentStyleMethod](ArgumentMap& arguments){return CreateStyleMethodArgument(argumentStyleMethod, arguments);})
				{
				}

				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod, ArgumentRawFunctionType* _argumentFunction)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
					, argumentFunction(_argumentFunction)
				{
				}

				GuiTemplateControlInstanceLoader(const WString& _typeName, const WString& _styleMethod, InitRawFunctionType* _initFunction)
					:typeName(GlobalStringKey::Get(_typeName))
					, styleMethod(_styleMethod)
					, initFunction(_initFunction)
				{
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::_ControlTemplate);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						return info;
					}
					return 0;
				}

				bool CanCreate(const TypeInfo& typeInfo)override
				{
					return typeName == typeInfo.typeName;
				}

				Ptr<workflow::WfStatement> CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					CHECK_ERROR(typeName == typeInfo.typeName, L"GuiTemplateControlInstanceLoader::CreateInstance# Wrong type info is provided.");
					vint indexControlTemplate = arguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);

					Ptr<WfExpression> createStyleExpr;
					if (indexControlTemplate == -1)
					{
						createStyleExpr = CreateIThemeCall(styleMethod);
					}
					else
					{
						if (auto controlTemplateTd = GetControlTemplateType(arguments.GetByIndex(indexControlTemplate)[0].expression, typeInfo, errors))
						{
							auto styleType = TypeInfoRetriver<TControlStyle*>::CreateTypeInfo();

							auto refFactory = CreateTemplateFactory(controlTemplateTd, errors);
							auto createStyle = MakePtr<WfNewClassExpression>();
							createStyle->type = GetTypeFromTypeInfo(styleType.Obj());
							createStyle->arguments.Add(refFactory);
							createStyleExpr = createStyle;
						}
						else
						{
							return nullptr;
						}
					}
				
					auto block = MakePtr<WfBlockStatement>();
					{
						auto varTemplate = MakePtr<WfVariableDeclaration>();
						varTemplate->name.value = L"<controlStyle>";
						varTemplate->expression = createStyleExpr;

						auto varStat = MakePtr<WfVariableStatement>();
						varStat->variable = varTemplate;
						block->statements.Add(varStat);
					}
					PrepareAdditionalArguments(typeInfo, variableName, arguments, errors, block);
					{
						auto controlType = TypeInfoRetriver<TControl*>::CreateTypeInfo();

						auto createControl = MakePtr<WfNewClassExpression>();
						createControl->type = GetTypeFromTypeInfo(controlType.Obj());
						{
							auto refControlStyle = MakePtr<WfReferenceExpression>();
							refControlStyle->name.value = L"<controlStyle>";

							createControl->arguments.Add(refControlStyle);
						}

						if (argumentFunction)
						{
							createControl->arguments.Add(argumentFunction(arguments));
						}
						AddAdditionalArguments(typeInfo, variableName, arguments, errors, createControl);

						auto refVariable = MakePtr<WfReferenceExpression>();
						refVariable->name.value = variableName.ToString();

						auto assignExpr = MakePtr<WfBinaryExpression>();
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refVariable;
						assignExpr->second = createControl;

						auto assignStat = MakePtr<WfExpressionStatement>();
						assignStat->expression = assignExpr;
						block->statements.Add(assignStat);
					}

					PrepareAdditionalArgumentsAfterCreation(typeInfo, variableName, arguments, errors, block);
					if (initFunction)
					{
						initFunction(variableName.ToString(), block);
					}
					return block;
				}
			};
#endif
		}
	}
}
#endif
